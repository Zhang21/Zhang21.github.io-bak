<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Shell - 风继续吹</title><meta name="Description" content="个人博客"><meta property="og:title" content="Shell" />
<meta property="og:description" content="参考：

Linux Shell脚本攻略
鸟哥的Linux私房菜
k-vim: https://github.com/wklken/k-vim



" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhang21.cn/linuxshell/" /><meta property="og:image" content="https://zhang21.cn/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-24T18:16:38&#43;00:00" />
<meta property="article:modified_time" content="2017-10-24T18:16:38&#43;00:00" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://zhang21.cn/logo.png"/>

<meta name="twitter:title" content="Shell"/>
<meta name="twitter:description" content="参考：

Linux Shell脚本攻略
鸟哥的Linux私房菜
k-vim: https://github.com/wklken/k-vim



"/>
<meta name="application-name" content="风继续吹">
<meta name="apple-mobile-web-app-title" content="风继续吹"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://zhang21.cn/linuxshell/" /><link rel="prev" href="https://zhang21.cn/yaml/" /><link rel="next" href="https://zhang21.cn/wireshark/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Shell",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/zhang21.cn\/linuxshell\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/zhang21.cn\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "Shell, Bash, Linux, Vim","wordcount":  53526 ,
        "url": "https:\/\/zhang21.cn\/linuxshell\/","datePublished": "2017-10-24T18:16:38+00:00","dateModified": "2017-10-24T18:16:38+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Zhang21","logo": "https:\/\/zhang21.cn\/leslie.png"},"author": {
                "@type": "Person",
                "name": "Zhang21"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="风继续吹"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>风继续吹</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/zhang21" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="风继续吹"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>风继续吹</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/zhang21" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Shell</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://zhang21.cn" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Zhang21</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/linux/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>linux</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2017-10-24">2017-10-24</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 53526 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 107 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#inode">inode</a>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#细节">细节</a></li>
        <li><a href="#讨论">讨论</a></li>
        <li><a href="#结构">结构</a></li>
        <li><a href="#大小">大小</a></li>
        <li><a href="#硬软链接">硬软链接</a>
          <ul>
            <li><a href="#硬链接">硬链接</a></li>
            <li><a href="#软链接">软链接</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#vim">vim</a>
      <ul>
        <li><a href="#警告信息">警告信息</a></li>
        <li><a href="#三种模式">三种模式</a>
          <ul>
            <li><a href="#一般模式">一般模式</a></li>
            <li><a href="#编辑模式">编辑模式</a></li>
            <li><a href="#命令模式">命令模式</a></li>
          </ul>
        </li>
        <li><a href="#visual模式">Visual模式</a></li>
        <li><a href="#环境设置与记录">环境设置与记录</a></li>
        <li><a href="#注意事项">注意事项</a>
          <ul>
            <li><a href="#中文编码问题">中文编码问题</a></li>
            <li><a href="#linux与dos的换行字符">Linux与Dos的换行字符</a></li>
            <li><a href="#语系编码转换">语系编码转换</a></li>
          </ul>
        </li>
        <li><a href="#使用正则">使用正则</a></li>
        <li><a href="#插件">插件</a>
          <ul>
            <li><a href="#vim插件管理器">vim插件管理器</a>
              <ul>
                <li><a href="#vundle">Vundle</a></li>
                <li><a href="#plug">Plug</a></li>
              </ul>
            </li>
            <li><a href="#vim常见插件">vim常见插件</a></li>
          </ul>
        </li>
        <li><a href="#k-vim">k-vim</a>
          <ul>
            <li><a href="#代码折叠">代码折叠</a></li>
          </ul>
        </li>
        <li><a href="#调试器">调试器</a>
          <ul>
            <li><a href="#gdb">GDB</a></li>
            <li><a href="#pdb和ipdb">pdb和ipdb</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#编码">编码</a>
      <ul>
        <li><a href="#unicode">Unicode</a></li>
        <li><a href="#ascii">ASCII</a></li>
        <li><a href="#utf-8">UTF-8</a></li>
      </ul>
    </li>
    <li><a href="#bash">Bash</a>
      <ul>
        <li><a href="#bash与shell">bash与shell</a>
          <ul>
            <li><a href="#硬件内核与shell">硬件、内核与shell</a></li>
            <li><a href="#命令行shell">命令行shell</a></li>
            <li><a href="#系统合法shell与etcshells">系统合法shell与/etc/shells</a></li>
            <li><a href="#bash-shell">bash shell</a></li>
            <li><a href="#type命令">type命令</a></li>
          </ul>
        </li>
        <li><a href="#shell变量">shell变量</a>
          <ul>
            <li><a href="#变量显示与设置">变量显示与设置</a></li>
            <li><a href="#变量设置规则">变量设置规则</a></li>
            <li><a href="#环境变量">环境变量</a></li>
            <li><a href="#语系变量">语系变量</a></li>
            <li><a href="#变量键盘读取数组与声明">变量键盘读取、数组与声明</a></li>
          </ul>
        </li>
        <li><a href="#bash-shell操作环境">bash shell操作环境</a>
          <ul>
            <li><a href="#路径与命令查找顺序">路径与命令查找顺序</a></li>
            <li><a href="#bash登录与欢迎消息">bash登录与欢迎消息</a></li>
            <li><a href="#bash环境配置文件">bash环境配置文件</a></li>
            <li><a href="#bash-shell快捷键">bash shell快捷键</a></li>
            <li><a href="#通配符与特殊符号">通配符与特殊符号</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#-注释">| 注释</a>
      <ul>
        <li><a href="#重定向">重定向</a></li>
        <li><a href="#管道">管道</a></li>
      </ul>
    </li>
    <li><a href="#bash特殊符号">Bash特殊符号</a></li>
    <li><a href="#-注释符---comments">| 注释符  | #comments</a></li>
    <li><a href="#shell脚本">shell脚本</a>
      <ul>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#编写一个shell脚本">编写一个shell脚本</a></li>
        <li><a href="#shell脚本判断式">shell脚本判断式</a></li>
        <li><a href="#shell脚本的默认变量">shell脚本的默认变量</a></li>
        <li><a href="#条件判断语句">条件判断语句</a>
          <ul>
            <li><a href="#ifthen语句">if&hellip;then语句</a></li>
            <li><a href="#caseesac语句">case&hellip;esac语句</a></li>
            <li><a href="#function功能">function功能</a></li>
          </ul>
        </li>
        <li><a href="#循环语句">循环语句</a>
          <ul>
            <li><a href="#while-do-done不定循环">while do done(不定循环)</a></li>
            <li><a href="#until-do-done不定循环">until do done(不定循环)</a></li>
            <li><a href="#for-do-done固定循环">for do done(固定循环)</a></li>
          </ul>
        </li>
        <li><a href="#shell脚本的追踪与调试">shell脚本的追踪与调试</a></li>
      </ul>
    </li>
    <li><a href="#小试牛刀">小试牛刀</a>
      <ul>
        <li><a href="#简介-1">简介</a></li>
        <li><a href="#终端打印echo">终端打印(<code>echo</code>)</a></li>
        <li><a href="#玩转变量和环境变量">玩转变量和环境变量</a></li>
        <li><a href="#通过shell进行数学运算">通过shell进行数学运算</a></li>
        <li><a href="#文件描述符重定向">文件描述符重定向</a></li>
        <li><a href="#数组和关联数组">数组和关联数组</a></li>
        <li><a href="#别名alias">别名(<code>alias</code>)</a></li>
        <li><a href="#获取设置日期和延时date">获取、设置日期和延时(<code>date</code>)</a></li>
        <li><a href="#调试脚本sh">调试脚本(<code>sh</code>)</a></li>
        <li><a href="#函数和参数function">函数和参数(<code>function</code>)</a></li>
        <li><a href="#读取命令序列输出---">读取命令序列输出(` `, $() )</a></li>
        <li><a href="#读取字符read">读取字符(<code>read</code>)</a></li>
        <li><a href="#字段分隔符和迭代器">字段分隔符和迭代器</a></li>
        <li><a href="#比较与测试">比较与测试</a></li>
      </ul>
    </li>
    <li><a href="#命令之乐">命令之乐</a>
      <ul>
        <li><a href="#简介-2">简介</a></li>
        <li><a href="#用cat进行拼接">用<code>cat</code>进行拼接</a></li>
        <li><a href="#录制与回放终端会话script">录制与回放终端会话(<code>script</code>)</a></li>
        <li><a href="#文件查找与文件列表find">文件查找与文件列表(<code>find</code>)</a>
          <ul>
            <li><a href="#利用stat命令查看atime-mtime-ctime">利用<code>stat</code>命令查看atime, mtime, ctime</a></li>
            <li><a href="#利用touch命令修改atime-mtime-ctime">利用<code>touch</code>命令修改atime, mtime, ctime</a></li>
          </ul>
        </li>
        <li><a href="#玩转xargs">玩转<code>xargs</code></a></li>
        <li><a href="#用tr进行转换">用<code>tr</code>进行转换</a></li>
        <li><a href="#校验和-与-核实文件完整性md5sum">校验和 与 核实文件完整性(<code>md5sum</code>)</a></li>
        <li><a href="#临时文件命名随机数">临时文件命名、随机数</a></li>
        <li><a href="#split命令分割文件">split命令分割文件</a></li>
        <li><a href="#根据扩展名切分文件名">根据扩展名切分文件名</a></li>
        <li><a href="#批量重命名和移动">批量重命名和移动</a></li>
        <li><a href="#拼写检查与词典操作">拼写检查与词典操作</a></li>
        <li><a href="#交互输入自动化">交互输入自动化</a></li>
      </ul>
    </li>
    <li><a href="#以文件之名">以文件之名</a>
      <ul>
        <li><a href="#简介-3">简介</a></li>
        <li><a href="#生成任意大小的文件dd">生成任意大小的文件(<code>dd</code>)</a></li>
        <li><a href="#文本文件的交集与差集">文本文件的交集与差集</a></li>
        <li><a href="#查找并删除重复文件">查找并删除重复文件</a></li>
        <li><a href="#创建长路径目录">创建长路径目录</a></li>
        <li><a href="#文件权限所有权和粘滞位">文件权限、所有权和粘滞位</a></li>
        <li><a href="#创建不可修改文件">创建不可修改文件</a></li>
        <li><a href="#批量生成空白文件">批量生成空白文件</a></li>
        <li><a href="#查找符号链接及其指向目标">查找符号链接及其指向目标</a></li>
        <li><a href="#列举文件类型统计信息">列举文件类型统计信息</a></li>
        <li><a href="#环回文件与挂载mount">环回文件与挂载(<code>mount</code>)</a></li>
        <li><a href="#生成iso文件以及混合iso">生成ISO文件以及混合ISO</a></li>
        <li><a href="#查找文件差异并进行修补">查找文件差异并进行修补</a></li>
        <li><a href="#head与tail"><code>head</code>与<code>tail</code></a></li>
        <li><a href="#只列出目录的其他方法">只列出目录的其他方法</a></li>
        <li><a href="#统计文件的行数单词数字符数">统计文件的行数、单词数、字符数</a></li>
        <li><a href="#目录树">目录树</a></li>
      </ul>
    </li>
    <li><a href="#让文本飞">让文本飞</a>
      <ul>
        <li><a href="#简介-4">简介</a></li>
        <li><a href="#正则表达式">正则表达式</a></li>
        <li><a href="#用grep在文件中搜索文本">用grep在文件中搜索文本</a></li>
        <li><a href="#用cut按列切分文件">用cut按列切分文件</a></li>
        <li><a href="#统计特定文件词频">统计特定文件词频</a></li>
        <li><a href="#sed入门">sed入门</a></li>
        <li><a href="#awk入门">awk入门</a></li>
        <li><a href="#对文件中的行单词字符进行迭代">对文件中的行、单词、字符进行迭代</a></li>
        <li><a href="#按列合并文件paste">按列合并文件(<code>paste</code>)</a></li>
        <li><a href="#以逆序形式打印行">以逆序形式打印行</a></li>
        <li><a href="#打印某个样式之前之后n行grep">打印某个样式之前/之后n行(<code>grep</code>)</a></li>
      </ul>
    </li>
    <li><a href="#一团乱麻没这回事">一团乱麻？没这回事</a>
      <ul>
        <li><a href="#入门">入门</a></li>
        <li><a href="#网站下载wgetcurl">网站下载(<code>wget</code>,<code>curl</code>)</a></li>
        <li><a href="#以格式化纯文本下载网页links">以格式化纯文本下载网页(<code>links</code>)</a></li>
        <li><a href="#从命令行访问163邮箱">从命令行访问163邮箱</a></li>
        <li><a href="#制作图片抓取器及下载工具">制作图片抓取器及下载工具</a></li>
        <li><a href="#查找网站中的无效链接lynx">查找网站中的无效链接(<code>lynx</code>)</a></li>
        <li><a href="#以post方式发送网页并读取响应">以POST方式发送网页并读取响应</a></li>
      </ul>
    </li>
    <li><a href="#plan-b">Plan B</a>
      <ul>
        <li><a href="#简介-5">简介</a></li>
        <li><a href="#用tar归档">用<code>tar</code>归档</a></li>
        <li><a href="#用cpio归档">用<code>cpio</code>归档</a></li>
        <li><a href="#用gunzip或gzip压缩">用<code>gunzip</code>或<code>gzip</code>压缩</a></li>
        <li><a href="#用bunzip或bzip压缩">用<code>bunzip</code>或<code>bzip</code>压缩</a></li>
        <li><a href="#lzma压缩"><code>lzma</code>压缩</a></li>
        <li><a href="#超高压缩率的squashfs文件系统">超高压缩率的<code>squashfs</code>文件系统</a></li>
        <li><a href="#加密工具与散列">加密工具与散列</a>
          <ul>
            <li><a href="#ccypt"><code>ccypt</code></a></li>
            <li><a href="#gpg"><code>gpg</code></a></li>
            <li><a href="#base64"><code>base64</code></a></li>
            <li><a href="#md5sum与sha1sum"><code>md5sum</code>与<code>sha1sum</code></a></li>
            <li><a href="#shadowlike散列salted散列">shadowlike散列(salted散列)</a></li>
          </ul>
        </li>
        <li><a href="#用rsync备份系统">用<code>rsync</code>备份系统</a></li>
      </ul>
    </li>
    <li><a href="#无网不利">无网不利</a>
      <ul>
        <li><a href="#简介-6">简介</a></li>
        <li><a href="#网络小知识">网络小知识</a></li>
        <li><a href="#ping"><code>ping</code></a></li>
        <li><a href="#列出网络上所有活动主机">列出网络上所有活动主机</a></li>
        <li><a href="#传输文件">传输文件</a></li>
        <li><a href="#ssh无秘钥认证">SSH无秘钥认证</a></li>
        <li><a href="#用ssh在远程主机上运行命令">用SSH在远程主机上运行命令</a></li>
        <li><a href="#在本地挂载远程驱动器sshfs">在本地挂载远程驱动器(<code>sshfs</code>)</a></li>
        <li><a href="#网络流量和端口分析">网络流量和端口分析</a></li>
        <li><a href="#tcpdump">tcpdump</a></li>
      </ul>
    </li>
    <li><a href="#当个好管家">当个好管家</a>
      <ul>
        <li><a href="#简介-7">简介</a></li>
        <li><a href="#统计磁盘使用情况dfdufdisk">统计磁盘使用情况(<code>df+du+fdisk</code>)</a></li>
        <li><a href="#计算命令执行时间">计算命令执行时间</a></li>
        <li><a href="#当前登录用户启动日志启动故障的相关信息wwholastblast">当前登录用户、启动日志、启动故障的相关信息(<code>w+who+lastb+last</code>)</a></li>
        <li><a href="#打印10条最常使用的命令history">打印10条最常使用的命令(<code>history</code>)</a></li>
        <li><a href="#列出占用cpu最多的进程">列出占用CPU最多的进程</a></li>
        <li><a href="#用watch监视命令输出">用<code>watch</code>监视命令输出</a></li>
        <li><a href="#对文件及目录访问进行记录inotifywait">对文件及目录访问进行记录(<code>inotifywait</code>)</a></li>
        <li><a href="#用logrotate管理日志文件">用<code>logrotate</code>管理日志文件</a></li>
        <li><a href="#用sys记录日志">用sys记录日志</a></li>
      </ul>
    </li>
    <li><a href="#管理重任">管理重任</a>
      <ul>
        <li><a href="#简介-8">简介</a></li>
        <li><a href="#收集进程信息toppspgrep">收集进程信息(<code>top+ps+pgrep</code>)</a></li>
        <li><a href="#杀死进程以及发送响应信息killkillalltrap">杀死进程以及发送响应信息(<code>kill+killall+trap</code>)</a></li>
        <li><a href="#which-whereis-file-whatis与平均负载"><code>which</code>, <code>whereis</code>, <code>file</code>, <code>whatis</code>与平均负载</a></li>
        <li><a href="#向用户终端发送消息">向用户终端发送消息</a></li>
        <li><a href="#收集系统信息">收集系统信息</a></li>
        <li><a href="#用proc收集信息">用/proc收集信息</a></li>
        <li><a href="#用cron进行调度">用cron进行调度</a>
          <ul>
            <li><a href="#cron的高级写法"><code>cron</code>的高级写法</a></li>
          </ul>
        </li>
        <li><a href="#用户管理常用命令">用户管理常用命令</a></li>
      </ul>
    </li>
    <li><a href="#iptables和firewalld">iptables和firewalld</a>
      <ul>
        <li><a href="#firewalld">firewalld</a>
          <ul>
            <li><a href="#区域管理">区域管理</a></li>
            <li><a href="#与服务一起使用">与服务一起使用</a></li>
          </ul>
        </li>
        <li><a href="#iptables">iptables</a>
          <ul>
            <li><a href="#表格链动作">表格/链/动作</a></li>
            <li><a href="#常用命令">常用命令</a></li>
            <li><a href="#解决重启失效">解决重启失效</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#分屏显示">分屏显示</a></li>
    <li><a href="#运维常见命令">运维常见命令</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>参考：</p>
<ul>
<li>Linux Shell脚本攻略</li>
<li>鸟哥的Linux私房菜</li>
<li>k-vim: <a href="https://github.com/wklken/k-vim">https://github.com/wklken/k-vim</a></li>
</ul>
<br>
<br/>
<hr>
<br/>
<br/>
<h1 id="inode">inode</h1>
<p>参考:</p>
<ul>
<li>wiki: <a href="https://zh.wikipedia.org/wiki/Inode">https://zh.wikipedia.org/wiki/Inode</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-speakingunix14/index.html" target="_blank" rel="noopener noreffer ">关于 inode</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener noreffer ">理解inode</a></li>
</ul>
<br/>
<br/>
<h2 id="简介">简介</h2>
<p><strong>inode</strong>是UNIX操作系统中的一种数据结构，它包含了与文件系统中各个<strong>文件系统对象</strong>(文件、目录、设备文件、socket、管道&hellip;)的元数据信息。在UNIX中创建文件系统时，同时将会创建大量的inode。通常，文件系统磁盘空间中大约百分之一空间分配给了inode表。</p>
<p>Unix先驱丹尼斯·里奇说，inode这个命名的来源可能是文件系统的存储组织为一个扁平数组，分层目录信息使用一个数作为文件系统这个扁平数组的索引值（index）。</p>
<br>
<p>理解inode，要从文件储存说起。</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做<strong>扇区</strong>（Sector）。每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个<strong>块</strong>（block）。这种由多个扇区组成的&quot;块&quot;，是文件存取的最小单位。&ldquo;块&quot;的大小，最常见的是4KB，即连续八个sector组成一个block。
文件数据都储存在<strong>块</strong>中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做<strong>inode</strong>，中文译名为<strong>索引节点</strong>。</p>
<br/>
<br/>
<br/>
<h2 id="细节">细节</h2>
<p>文件系统创建（格式化）时，就把存储区域分为两大连续的存储区域。一个用来保存文件系统对象的元信息数据，这是由inode组成的表，每个inode默认是256字节或者128字节。另一个用来保存<strong>文件系统对象</strong>的内容数据，划分为512字节的扇区，以及由8个扇区组成的4K字节的块。块是读写时的基本单位。一个文件系统的inode的总数是固定的。这限制了该文件系统所能存储的文件系统对象的总数目。典型的实现下，所有inode占用了文件系统1%左右的存储容量。</p>
<p>文件系统中每个文件系统对象对应一个inode数据，并用一个整数值来辨识。这个整数常被称为inode号码（i-number或inode number）。由于文件系统的inode表的存储位置、总条目数量都是固定的，因此可以用inode号码去索引查找inode表。</p>
<p>Inode存储了文件系统对象的一些元信息，如所有者、访问权限（读、写、执行）、类型（是文件还是目录）、内容修改时间、inode修改时间、上次访问时间、对应的文件系统存储块的地址，等等。知道了1个文件的inode号码，就可以在inode元数据中查出文件内容数据的存储地址。</p>
<p>文件名与目录名是文件系统对象便于使用的别名。一个文件系统对象可以有多个别名，但只能有一个inode，并用这个inode来索引文件系统对象的存储位置。</p>
<ul>
<li>inode不包含文件名或目录名的字符串，只包含文件或目录的元信息</li>
<li>Unix的文件系统的目录也是一种文件。打开目录，实际上就是读取目录文件。目录文件的结构是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件或目录的名字，以及该文件或目录名对应的inode号码</li>
<li>文件系统中的一个文件是指存放在其所属目录的目录文件中的一个目录项，其所对应的inode的类别为文件；文件系统中的一个目录是指存放在其父目录文件中的一个目录项，其所对应的inode的类别为目录。可见，多个文件可以对应同一个inode;多个目录可以对应同一个inode</li>
<li>文件系统中如果两个文件或者两个目录具有相同的inode号码，那么就称它们是<strong>硬链接</strong>关系。实际上都是这个inode的别名。换句话说，一个inode对应的所有文件（或目录）中的每一个，都对应着文件系统某个目录文件中唯一的一个目录项</li>
<li>创建一个目录时，实际做了3件事：在其父目录文件中增加一个条目；分配一个inode；再分配一个存储块，用来保存当前被创建目录包含的文件与子目录。被创建的目录文件中自动生成两个子目录的条目，名称分别是：<code>.</code>和<code>..</code>。前者与该目录具有相同的inode号码，因此是该目录的一个硬链接。后者的inode号码就是该目录的父目录的inode号码。所以，任何一个目录的硬链接总数，总是等于它的子目录总数（含隐藏目录）加2。即每个子目录文件中的<code>..</code>条目，加上它自身的目录文件中的<code>.</code>条目。再加上父目录文件中的对应该目录的条目。</li>
<li>通过文件名打开文件，实际上是分成三步实现：首先，操作系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</li>
</ul>
<br/>
<br/>
<br/>
<h2 id="讨论">讨论</h2>
<ul>
<li>一个文件系统对象可以有多个名字，这些具有硬链接关系的文件系统对象名字具有相同的inode号码，彼此是平等的。即首个被创建的文件并没有特殊的地位。这与符号链接不同。一个符号链接文件有自己的inode，符号链接文件的内容是它所指向的文件的名字。因此删除符号链接所指向的文件，将导致这个符号链接文件在访问时报错</li>
<li>删除一个文件或目录，实际上是把它的inode的链接数减1。这并不影响指向此inode的别的硬链接</li>
<li>一个inode如果没有硬链接，此时inode的链接数为0，文件系统将回收该inode所指向的存储块，并回收该inode自身</li>
<li>从一个inode，通常是无法确定是用哪个文件名查到此inode号码的。打开一个文件后，操作系统实际上就抛掉了文件名，只保留了inode号码来访问文件的内容。库函数<code>getcwd()</code>用来查询当前工作目录的绝对路径名。其实现是从当前工作目录的inode逐级查找其上级目录的inode，最后拼出整个绝对路径的名字</li>
<li>历史上，对目录的硬链接是可能的。这可以使目录结构成为一个有向图，而不是通常的目录树的有向无环图。一个目录甚至可以是自身的父目录。现代文件系统一般禁止这些混淆状态，只有根目录保持了特例：根目录是自身的父目录。<code>ls /..</code>就是根目录的内容</li>
<li>一个文件或目录在文件系统内部移动时，其inode号码不变。文件系统碎片整理可能会改变一个文件的物理存储位置，但其inode号码不变。非UNIX的FAT及其派生的文件系统是无法实现inode不变这一特点。</li>
<li>inode文件系统中安装新库十分容易。当一些进程正在使用一个库时，其它进程可以替换该库文件名字的inode号码指向新创建的inode，随后对该库的访问都被自动引导到新inode所指向的新的库文件的内容。这减少了替换库时重启系统的需要。而旧的inode的链接数已经为0，在使用旧库的进程结束后，旧的inode与旧库文件会被系统自动回收。</li>
</ul>
<br/>
<br/>
<br/>
<h2 id="结构">结构</h2>
<p>POSIX标准强制规范了文件系统的行为。每个文件系统对象必须具有：</p>
<ul>
<li>设备ID，标识容纳该文件的设备</li>
<li>以字节为单位的文件大小</li>
<li>磁盘块</li>
<li>用户(uid)</li>
<li>组(gid)</li>
<li>r/w/x权限</li>
<li>时间戳
<ul>
<li>ctime: inode自身被修改的时间；</li>
<li>mtime：内容修改的时间；</li>
<li>atime：最后一次被访问的时间</li>
</ul>
</li>
<li>链接数，有多少硬链接指向此inode</li>
</ul>
<p>使用<code>stat</code>系统调用可以查询一个文件的inode号码及一些元信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 使用stat查看某个文件inode</span>
stat  _config.yml
  File: <span class="s1">&#39;_config.yml&#39;</span>
  Size: <span class="m">2522</span>            Blocks: <span class="m">8</span>          IO Block: <span class="m">4096</span>   regular file
Device: fd02h/64770d    Inode: <span class="m">52354</span>       Links: <span class="m">1</span>
Access: <span class="o">(</span>0664/-rw-rw-r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/ zhang<span class="o">)</span>   Gid: <span class="o">(</span> 1000/ zhang<span class="o">)</span>
Access: 2019-04-22 09:39:28.735991059 +0800
Modify: 2018-07-07 15:37:50.000000000 +0800
Change: 2018-12-11 07:38:26.287109004 +0800
 Birth: -
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<br/>
<h2 id="大小">大小</h2>
<p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode表（inode table），存放inode所包含的信息。</p>
<p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是磁盘还未存满的情况。这时，就无法在磁盘上创建新文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 查看inode</span>
df -i
Filesystem                 Inodes  IUsed     IFree IUse% Mounted on
overlay                  <span class="m">26214400</span> <span class="m">597690</span>  <span class="m">25616710</span>    3% /
tmpfs                      <span class="m">485005</span>     <span class="m">17</span>    <span class="m">484988</span>    1% /dev
tmpfs                      <span class="m">485005</span>     <span class="m">16</span>    <span class="m">484989</span>    1% /sys/fs/cgroup
/dev/mapper/centos-home <span class="m">215418880</span> <span class="m">297955</span> <span class="m">215120925</span>    1% /home/test
/dev/mapper/centos-root  <span class="m">26214400</span> <span class="m">597690</span>  <span class="m">25616710</span>    3% /etc/hosts
shm                        <span class="m">485005</span>      <span class="m">1</span>    <span class="m">485004</span>    1% /dev/shm
tmpfs                      <span class="m">485005</span>      <span class="m">1</span>    <span class="m">485004</span>    1% /proc/acpi
tmpfs                      <span class="m">485005</span>      <span class="m">1</span>    <span class="m">485004</span>    1% /proc/scsi
tmpfs                      <span class="m">485005</span>      <span class="m">1</span>    <span class="m">485004</span>    1% /sys/firmware
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<br/>
<h2 id="硬软链接">硬软链接</h2>
<br/>
<h3 id="硬链接">硬链接</h3>
<p>一般情况下，文件名和inode号码是&quot;一一对应&quot;关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p>
<p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为&quot;硬链接&rdquo;（hard link）。</p>
<p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做&quot;链接数&quot;，记录指向该inode的文件名总数，这时就会增加1。
反过来，删除一个文件名，就会使得inode节点中的&quot;链接数&quot;减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p>
<p>这里顺便说一下目录文件的&quot;链接数&quot;。创建目录时，默认会生成两个目录项：&quot;.&ldquo;和&rdquo;..&quot;。前者的inode号码就是当前目录的inode号码，等同于当前目录的&quot;硬链接&quot;；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的&quot;硬链接&quot;。所以，任何一个目录的&quot;硬链接&quot;总数，总是等于2加上它的子目录总数（含隐藏目录）。</p>
<br/>
<br/>
<h3 id="软链接">软链接</h3>
<p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的&quot;软链接&quot;（soft link）或者&quot;符号链接（symbolic link）。</p>
<p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：&ldquo;No such file or directory&rdquo;。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode&quot;链接数&quot;不会因此发生变化。</p>
<br/>
<br/>
<hr>
<br/>
<br/>
<h1 id="vim">vim</h1>
<p>在Linux中使用文本编辑器来编辑你的Linux参数配置文件是一件很重要的事情，因此系统管理员至少应该熟悉一种文本编辑器。</p>
<p>在Linux中，绝大部分的配置文件都是以ASCII(键盘上可找到)的纯文本形式。因此利用简单的文本编辑器就能修改。</p>
<p>ASCII（发音：/ˈæski/ ass-kee[1]，American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。从[0000 0000 - 0111 1111]共128个字符。</p>
<br/>
<p>vi文本编辑器</p>
<ul>
<li>所有的Unix Like系统都会内置vi文本编辑器，其他的文本编辑器则不一定存在</li>
<li>很多软件的编辑接口都会主动调用vi(如 crontab等命令)</li>
<li>vim是vi的高级版本
<ul>
<li>vim具有程序编辑的能力，可以主动以字体颜色辨别语法的正确性，方便程序设计</li>
</ul>
</li>
<li>程序简单，编辑速度相当快速</li>
<li>vi中的tab键所得结果与空格符不一样</li>
<li>vi中，数字是很有意义的
<ul>
<li>数字通常代表重复做几次，或去到第几个的意思</li>
</ul>
</li>
</ul>
<br>
<br>
<h2 id="警告信息">警告信息</h2>
<p>当我们使用vim时，vim会在当前目录下再创建一个名为filename.swp的暂存文件。</p>
<p>由于vim的工作被不正常中断，导致暂存盘无法通过正常流程来结束，所以暂存文件就不会消失。此时编辑文件就会出现某些异常情况。</p>
<ul>
<li>可能有其他人或程序同时在编辑这个文件</li>
<li>在前一个vim的环境中，可能因为某些不明原因导致vim中断(crashed)</li>
</ul>
<br>
<br/>
<h2 id="三种模式">三种模式</h2>
<p>vim包括三种模式：</p>
<ul>
<li>一般模式</li>
<li>编辑模式</li>
<li>命令行模式</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/vim.png"
        data-srcset="/images/vim.png, /images/vim.png 1.5x, /images/vim.png 2x"
        data-sizes="auto"
        alt="/images/vim.png"
        title="VIM" /></p>
<br/>
<h3 id="一般模式">一般模式</h3>
<p>命令 | 说明</p>
<ul>
<li>| -
x | 向后删除一个字符
X | 向前删除一个字符
nx,nX | 向前/后 删除n个字符
dd | 删除当前行
D | 删除当前行所有字符，使之成为空行
ndd | 删除光标所在行的向下n行
d1G | 删除光标所在行到第一行
dG | 删除光标所在行到最后一行
yy |  复制光标所在行
y1G | 复制光标所在行到第一行
yG | 复制光标所在行到最后一行
ynj | 复制光标所在行和向下n行
dnj | 删除光标所在行和向下n行
p | 将复制的数据粘贴到光标下一行
P | 将复制的数据粘贴到光标上一行
J | 将光标所在行与下一行结合成一行
u | undo,恢复前一个操作
ctrl+r | 重做上一个操作
. | 重复前一个操作</li>
</ul>
<br/>
<h3 id="编辑模式">编辑模式</h3>
<p>命令 | 说明</p>
<ul>
<li>| -
i | 在当前光标所在处插入文字
I | 在光标所在行第一个非空字符插入文字
a | 在当前光标后插入文字
A | 在当前光标所在行最后插入文字
o | 在光标所在行的下一行行首插入字符
O | 在光标所在行的上一行行首插入字符
r | 替换光标所在那一个字符
R | 一直替换光标所指的文字，直到退出
Esc | 退出，回到一般模式</li>
</ul>
<br/>
<h3 id="命令模式">命令模式</h3>
<p>命令 | 说明</p>
<ul>
<li>| -
h | 方向左
j | 方向下
k | 方向上
l | 方向右</li>
</ul>
<ul>
<li>| 光标移到下一行的第一个非空字符</li>
</ul>
<ul>
<li>| 光标移到当前行的第一个非空字符
0 | 光标移到当前行的第一个字符
$ | 光标移到当前行的最后一个字符
n空格 | 光标在当前行向右移动n个字符
G | 光标移到最后一行的第一个非空字符
gg | 光标移到第一行的第一个非空字符，相当于1G
nG | 光标移到第n行的第一个非空字符
/word | 在光标之后查找word字符串
?word | 在光标之前查找word字符串
n/N | 重复前一个查找
:s/word1/word2 | 在光标当前行将word1替换成word2
:n1,n2s/word1/word2/g | 在n1行-n2行间将word1替换成word2
%s/word1/word2/gc | 全局将word1替换成word2，在替换前让用户确认(confirm)
:w | 保存到文件
:w file2 | 保存到file2文件
:r file3 | 从file3文件读取数据并写入
:wq/:x | 保存并退出
:q | 退出
:q! | 强制退出
:!cmd | 执行命令
:r!cmd | 将执行命令写入
:set nu | 显示行号
:set nonu | 取消行号
:n1,n2w file4 | 将n1行-n2行的内容保存到file4文件</li>
</ul>
<br>
<br/>
<br>
<h2 id="visual模式">Visual模式</h2>
<p>参考:</p>
<ul>
<li><a href="https://vimjc.com/vim-visual-mode.html">https://vimjc.com/vim-visual-mode.html</a></li>
</ul>
<p>Visual Mode下可以选择一块编辑区域，然后对选中的文件内容执行<strong>复制</strong>、<strong>粘贴</strong>、<strong>插入</strong>、<strong>删除</strong>、<strong>替换</strong>、<strong>改变大小写</strong>等操作，是vim使用过程中常用的一种模式。</p>
<p>在vim命令模式下，使用<code>v</code>或<code>V</code>或<code>ctrl+v</code>都可进入可视化模式。这三种模式的主要区别在于:</p>
<ul>
<li><code>v</code>字符选择模式: 选中光标经过的所有字符</li>
<li><code>V</code>行选择模式: 选中光标经过的所有行</li>
<li><code>ctrl+v</code>块选择模式: 选中一整个矩形框表示的所有文本</li>
</ul>
<p>具体细致的操作就不写了，但却是非常使用。</p>
<br>
<br>
<br>
<h2 id="环境设置与记录">环境设置与记录</h2>
<p>因为vim会主动将你曾经的行为记录下来，好方便下次操作。这个文件是自动生成的。</p>
<ul>
<li>~/.vim.info</li>
<li>~/.vim.rc</li>
<li>整体vim设置
<ul>
<li>/etc/vimrc</li>
</ul>
</li>
</ul>
<p>此外，每个Distribution对vim的默认环境都不太相同。所以你可能需要设置成你自己的工作方式。</p>
<p>参数 | 说明</p>
<ul>
<li>| -
:set nu <br> :set nonu | 行号设定
:set hlsearch <br/> :set nohlsearch | 高亮设定
:set autoindent <br/> :set noautoindent | 自动缩排设定
:set backup | 自动备份设定
:set ruler | 状态栏设定
:set showmode | 模式显示设定，如INSERT
:set backspace=(012) | 设定退格(backspace)值
:set all | 显示所有环境参数
:set | 显示与系统默认值不同的参数
:syntax on/off | 程序语法显示
:set bg=dark/light | 设定背景颜色</li>
</ul>
<br>
<p>栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">vim /root/.vimrc


<span class="s2">&#34;这是注释&#34;</span>
<span class="nb">set</span> nu
<span class="nb">set</span> ruler
<span class="nb">set</span> <span class="nv">bg</span><span class="o">=</span>dark
syntax on
<span class="nb">set</span> hlsearch
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<h2 id="注意事项">注意事项</h2>
<br>
<h3 id="中文编码问题">中文编码问题</h3>
<p>修改语系编码： <code>LANG=zh_CN.utf-8</code></p>
<br>
<h3 id="linux与dos的换行字符">Linux与Dos的换行字符</h3>
<ul>
<li>Linux的换行(Enter)为LF符号($)</li>
<li>Dos的换行(Enter)为CRLF符号(^M$)</li>
</ul>
<p>不同系统之间复制纯文本文件可能会有问题，此时可以转换：</p>
<ul>
<li>unix2dos file newfile</li>
<li>dos2unix file newfile</li>
</ul>
<br>
<h3 id="语系编码转换">语系编码转换</h3>
<p><code>iconv</code> - convert text from one character encoding to another</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#iconv -f 源编码 -t 新编码 filename [-o newfile]</span>
<span class="c1">#-o，转换到新文件</span>

iconf -f big4 -t utf8 old.big5 -o new.utf8
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<br/>
<h2 id="使用正则">使用正则</h2>
<p><strong>VIM里的正则用着太爽了，不用不知道，用了非常好！请注意转义哈！</strong></p>
<br>
<p>在vim里的查找(<code>/, ?</code>)和替换(<code>:s, :1,ns, :%s</code>)功能中，使用正则可极大提高效率。</p>
<p>vim毕竟是个编辑器，如果直接饮用正则表达式的元字符会造成一些麻烦。所以需要对正则元字符进行转义。</p>
<p>vim有一个<code>magic</code>，可以设置哪些正则元字符需要转义，哪些不需要。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">vim

:set magic
:set nomagic


magic <span class="o">(</span><span class="se">\m</span><span class="o">)</span>：除了 $ . * ^ 之外的元字符都需要转义，也就是反斜杠<span class="o">(</span><span class="se">\)</span>
/<span class="se">\m</span>.*    <span class="c1">#查找任意字符串</span>

nomagic <span class="o">(</span><span class="se">\M</span><span class="o">)</span>：除了<span class="sb">`</span>$ ^<span class="sb">`</span>之外的元字符都需要转义
/<span class="se">\M</span>.*    <span class="c1">#查找特定字符串.*</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>我不建议使用，这样使得vim使用很错乱。还是老老实实使用转义好些。</p>
<br/>
<p>正则表达式的元字符参考本文档的<strong>正则表达式</strong>章节。</p>
<p>栗子:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">vim 1.txt


# \s，空格
# 删除每行开通的空格
:%s/^\s*//g


# 去掉开头的行号
11, 20s/^[0-9]\{2\}//g



# 查找
/[0-9]\{3,5\}


# 查找多个
/aaa\|bbb\|ccc
#替换多个
:%s/aaa\|bbb/HAHAHAHA/g
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<br/>
<h2 id="插件">插件</h2>
<p>插件是一种扩展VIM功能的方法。VIM将插件分为：</p>
<ul>
<li>全局插件(global)：无条件加载和操作</li>
<li>文件类型插件(filetype)：仅为特定文件类型加载和操作，参阅<code>vim --&gt; :help filetype</code></li>
</ul>
<p>VIM默认会在特定位置查找插件：</p>
<ul>
<li>Linux/OS X： <code>~/.vim/plugin</code></li>
<li>Windows： <code>$HOME/vimfiles/plugin</code></li>
<li>文件类型插件为<code>ftplugin</code></li>
</ul>
<br>
<p>插件只是VIM脚本，因此你可以使用它们来定义函数、映射和命令，就像在<code>.vimrc</code>中一样。
插件通常不仅仅是位于相应目录中的单个<code>.vim</code>文件。它们通常还包括自动加载脚本(<code>:help autoload</code>)，语法脚本(<code>:help syntax</code>)和缩进处理脚本。将这些脚本中的所有代码打包在一起，提供强大的钩子来增强VIM。</p>
<p>VIM內建的帮助(<code>:help plugin</code>)包含各种详细信息。有一些优秀资源:</p>
<ul>
<li><a href="http://learnvimscriptthehardway.stevelosh.com/" target="_blank" rel="noopener noreffer ">Learn Vimscript the Hard Way </a></li>
<li><a href="http://stevelosh.com/blog/2011/09/writing-vim-plugins/" target="_blank" rel="noopener noreffer ">Writing Vim Plugins</a></li>
</ul>
<br>
<p>可使用放在适当的目录的插件并启动VIM。当然，有些插件可能有比较复杂的安装过程(比如YouCompleteMe插件)。
目前，像Pathogen和Vundle这样的插件管理器是手动安装插件文件的流行替代品，特别是因为插件通常带有多个文件。</p>
<br/>
<h3 id="vim插件管理器">vim插件管理器</h3>
<p>当没有插件管理器时，Vim 用户必须手动下载 tarball 包形式的插件，并将它们解压到 ~/.vim 目录中。在少量插件的时候可以。但当他们安装更多的插件时，就会变得一团糟。所有插件文件分散在单个目录中，用户无法找到哪个文件属于哪个插件。此外，他们无法找到他们应该删除哪个文件来卸载插件。这时 Vim 插件管理器就可以派上用场。插件管理器将安装插件的文件保存在单独的目录中，因此管理所有插件变得非常容易。</p>
<p>介绍几个常见的VIM插件管理器:</p>
<ul>
<li>Pathogen: <a href="https://github.com/tpope/vim-pathogen">https://github.com/tpope/vim-pathogen</a></li>
<li>Vundle: <a href="https://github.com/VundleVim/Vundle.vim">https://github.com/VundleVim/Vundle.vim</a></li>
<li>Plug: <a href="https://github.com/junegunn/vim-plug">https://github.com/junegunn/vim-plug</a></li>
</ul>
<br>
<h4 id="vundle">Vundle</h4>
<p>安装Vundle前请先安装<code>vim</code>和<code>git</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install -y vim git

<span class="c1"># 下载Vundle</span>
git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim

<span class="c1"># 配置vundle</span>
vim ~/.vimrc

<span class="c1">#加入以下内容</span>
<span class="nb">set</span> nocompatible              <span class="s2">&#34; required
</span><span class="s2">filetype off                  &#34;</span> required
<span class="nb">set</span> <span class="nv">rtp</span><span class="o">+=</span>~/.vim/bundle/Vundle.vim
call vundle#begin<span class="o">()</span>
Plugin <span class="s1">&#39;gmarik/Vundle.vim&#39;</span>
call vundle#end<span class="o">()</span>            <span class="s2">&#34; required
</span><span class="s2">filetype plugin indent on    &#34;</span> required

<span class="s2">&#34; 设置包括vundle和初始化相关的runtime path
</span><span class="s2">set rtp+=~/.vim/bundle/Vundle.vim
</span><span class="s2">call vundle#begin()
</span><span class="s2">&#34;</span> 另一种选择, 指定一个vundle安装插件的路径
<span class="s2">&#34;call vundle#begin(&#39;~/some/path/here&#39;)
</span><span class="s2">
</span><span class="s2">&#34;</span> 让vundle管理插件版本,必须
Plugin <span class="s1">&#39;VundleVim/Vundle.vim&#39;</span>

<span class="s2">&#34; 以下范例用来支持不同格式的插件安装.
</span><span class="s2">&#34;</span> 请将安装插件的命令放在vundle#begin和vundle#end之间.
<span class="s2">&#34; Github上的插件
</span><span class="s2">&#34;</span> 格式为 Plugin <span class="s1">&#39;用户名/插件仓库名&#39;</span>
Plugin <span class="s1">&#39;tpope/vim-fugitive&#39;</span>
<span class="s2">&#34; 来自 http://vim-scripts.org/vim/scripts.html 的插件
</span><span class="s2">&#34;</span> Plugin <span class="s1">&#39;插件名称&#39;</span> 实际上是 Plugin <span class="s1">&#39;vim-scripts/插件仓库名&#39;</span> 只是此处的用户名可以省略
Plugin <span class="s1">&#39;L9&#39;</span>
<span class="s2">&#34; 由Git支持但不再github上的插件仓库 Plugin &#39;git clone 后面的地址&#39;
</span><span class="s2">Plugin &#39;git://git.wincent.com/command-t.git&#39;
</span><span class="s2">&#34;</span> 本地的Git仓库<span class="o">(</span>例如自己的插件<span class="o">)</span> Plugin <span class="s1">&#39;file:///+本地插件仓库绝对路径&#39;</span>
Plugin <span class="s1">&#39;file:///home/gmarik/path/to/plugin&#39;</span>
<span class="s2">&#34; 插件在仓库的子目录中.
</span><span class="s2">&#34;</span> 正确指定路径用以设置runtimepath. 以下范例插件在sparkup/vim目录下
Plugin <span class="s1">&#39;rstacruz/sparkup&#39;</span>, <span class="o">{</span><span class="s1">&#39;rtp&#39;</span>: <span class="s1">&#39;vim/&#39;</span><span class="o">}</span>
<span class="s2">&#34; 安装L9，如果已经安装过这个插件，可利用以下格式避免命名冲突
</span><span class="s2">Plugin &#39;ascenator/L9&#39;, {&#39;name&#39;: &#39;newL9&#39;}
</span><span class="s2">
</span><span class="s2">&#34;</span> 你的所有插件需要在下面这行之前
call vundle#end<span class="o">()</span>            <span class="s2">&#34; 必须
</span><span class="s2">filetype plugin indent on    &#34;</span> 必须 加载vim自带和插件相应的语法和文件类型相关脚本
<span class="s2">&#34; 忽视插件改变缩进,可以使用以下替代:
</span><span class="s2">&#34;</span>filetype plugin on
<span class="s2">&#34;
</span><span class="s2">&#34;</span> 简要帮助文档
<span class="s2">&#34; :PluginList       - 列出所有已配置的插件
</span><span class="s2">&#34;</span> :PluginInstall    - 安装插件,追加 <span class="sb">`</span>!<span class="sb">`</span> 用以更新或使用 :PluginUpdate
<span class="s2">&#34; :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存
</span><span class="s2">&#34;</span> :PluginClean      - 清除未使用插件,需要确认<span class="p">;</span> 追加 <span class="sb">`</span>!<span class="sb">`</span> 自动批准移除未使用插件
<span class="s2">&#34;
</span><span class="s2">&#34;</span> 查阅 :h vundle 获取更多细节和wiki以及FAQ
<span class="s2">&#34; 将你自己对非插件片段放在这行之后
</span><span class="s2">
</span><span class="s2">
</span><span class="s2"># 安装插件
</span><span class="s2"># vim中
</span><span class="s2">:PluginInstall
</span><span class="s2">
</span><span class="s2"># bash
</span><span class="s2">vim _PluginInstall +qall
</span><span class="s2">
</span><span class="s2">
</span><span class="s2">
</span><span class="s2"># 查找插件
</span><span class="s2"># vim
</span><span class="s2">:PluginSearch
</span><span class="s2"># 要从vimscripts网站刷新本地的列表
</span><span class="s2">:PluginSearch!
</span><span class="s2">
</span><span class="s2">
</span><span class="s2"># 查看已安装插件
</span><span class="s2"># vim
</span><span class="s2">:PluginList
</span><span class="s2">
</span><span class="s2">
</span><span class="s2"># 更新插件
</span><span class="s2"># vim
</span><span class="s2">:PluginUpdate
</span></code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<h4 id="plug">Plug</h4>
<p>它是一个速度非常快的、极简的 vim 插件管理器。它可以并行地安装或更新插件。你还可以回滚更新。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 下载安装</span>
curl -fLo ~/.vim/autoload/plug.vim --create-dirs <span class="se">\
</span><span class="se"></span>    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim


<span class="c1"># 配置</span>
vim ~/.vimrc
<span class="c1"># 以 call plug#begin(PLUGIN_DIRECTORY) 开始，并以 call plug#end() 结束</span>
<span class="c1"># 栗子</span>
<span class="s2">&#34; Specify a directory for plugins
</span><span class="s2">&#34;</span> - For Neovim: ~/.local/share/nvim/plugged
<span class="s2">&#34; - Avoid using standard Vim directory names like &#39;plugin&#39;
</span><span class="s2">call plug#begin(&#39;~/.vim/plugged&#39;)
</span><span class="s2">
</span><span class="s2">&#34;</span> Make sure you use single quotes

<span class="s2">&#34; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align
</span><span class="s2">Plug &#39;junegunn/vim-easy-align&#39;
</span><span class="s2">
</span><span class="s2">&#34;</span> Any valid git URL is allowed
Plug <span class="s1">&#39;https://github.com/junegunn/vim-github-dashboard.git&#39;</span>

<span class="s2">&#34; Multiple Plug commands can be written in a single line using | separators
</span><span class="s2">Plug &#39;SirVer/ultisnips&#39; | Plug &#39;honza/vim-snippets&#39;
</span><span class="s2">
</span><span class="s2">&#34;</span> On-demand loading
Plug <span class="s1">&#39;scrooloose/nerdtree&#39;</span>, <span class="o">{</span> <span class="s1">&#39;on&#39;</span>:  <span class="s1">&#39;NERDTreeToggle&#39;</span> <span class="o">}</span>
Plug <span class="s1">&#39;tpope/vim-fireplace&#39;</span>, <span class="o">{</span> <span class="s1">&#39;for&#39;</span>: <span class="s1">&#39;clojure&#39;</span> <span class="o">}</span>

<span class="s2">&#34; Using a non-master branch
</span><span class="s2">Plug &#39;rdnetto/YCM-Generator&#39;, { &#39;branch&#39;: &#39;stable&#39; }
</span><span class="s2">
</span><span class="s2">&#34;</span> Using a tagged release<span class="p">;</span> wildcard allowed <span class="o">(</span>requires git 1.9.2 or above<span class="o">)</span>
Plug <span class="s1">&#39;fatih/vim-go&#39;</span>, <span class="o">{</span> <span class="s1">&#39;tag&#39;</span>: <span class="s1">&#39;*&#39;</span> <span class="o">}</span>

<span class="s2">&#34; Plugin options
</span><span class="s2">Plug &#39;nsf/gocode&#39;, { &#39;tag&#39;: &#39;v.20150303&#39;, &#39;rtp&#39;: &#39;vim&#39; }
</span><span class="s2">
</span><span class="s2">&#34;</span> Plugin outside ~/.vim/plugged with post-update hook
Plug <span class="s1">&#39;junegunn/fzf&#39;</span>, <span class="o">{</span> <span class="s1">&#39;dir&#39;</span>: <span class="s1">&#39;~/.fzf&#39;</span>, <span class="s1">&#39;do&#39;</span>: <span class="s1">&#39;./install --all&#39;</span> <span class="o">}</span>

<span class="s2">&#34; Unmanaged plugin (manually installed and updated)
</span><span class="s2">Plug &#39;~/my-prototype-plugin&#39;
</span><span class="s2">
</span><span class="s2">&#34;</span> Initialize plugin system
call plug#end<span class="o">()</span>



<span class="c1"># 重载.vimrc以使用vim</span>
<span class="nb">source</span> ~/.vimrc
<span class="c1"># vim</span>
:PlugInstall
:PlugUpdate
:PlugClean


<span class="c1"># 升级plug</span>
<span class="c1"># vim</span>
:PlugUpgrade
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<br/>
<h3 id="vim常见插件">vim常见插件</h3>
<ul>
<li><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener noreffer ">NERDTree</a>： 文档树</li>
<li><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener noreffer ">YouCompleteMe</a>： 代码补全</li>
<li><a href="https://github.com/luochen1990/rainbow" target="_blank" rel="noopener noreffer ">Rainbow</a>： 彩虹括号</li>
<li><a href="https://github.com/mbbill/undotree" target="_blank" rel="noopener noreffer ">UndoTree</a>： 关闭vim后也可代码撤回</li>
<li><a href="https://github.com/airblade/vim-gitgutter" target="_blank" rel="noopener noreffer ">vim-gitgutter</a>：显示git信息</li>
<li><a href="https://github.com/kien/ctrlp.vim" target="_blank" rel="noopener noreffer ">ctrlp</a>：</li>
<li><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener noreffer ">tagbar</a>：浏览当前文件的标签并获得其结构的概述</li>
</ul>
<br/>
<br/>
<br/>
<h2 id="k-vim">k-vim</h2>
<p>k-vim: <a href="https://github.com/wklken/k-vim">https://github.com/wklken/k-vim</a></p>
<p>k-vim是一份很好的vim配置，我个人使用的是这个配置。</p>
<br/>
<br/>
<h3 id="代码折叠">代码折叠</h3>
<p>vim支持多种代码折叠:</p>
<ul>
<li>manual: 手工定义折叠</li>
<li>indent: 用缩进表示折叠</li>
<li>expr: 用表达式来定义折叠</li>
<li>syntax: 用语法高亮来定义折叠</li>
<li>diff: 对没有更改的文本进行折叠</li>
<li>marker: 用标志折叠</li>
</ul>
<br>
<p>k-vim里配置的折叠方法是<code>indent</code>。此缩进方法的操作如下：</p>
<ul>
<li><code>za</code>: 折叠缩进处的代码</li>
<li><code>,zz</code>: k-vim配置的<code>za</code></li>
<li><code>zM</code>: 关闭所有的折叠</li>
<li><code>zR</code>: 打开所有的折叠</li>
</ul>
<br/>
<br/>
<br/>
<h2 id="调试器">调试器</h2>
<p>介绍vim下常用的代码调试器(debugger)。</p>
<br>
<h3 id="gdb">GDB</h3>
<ul>
<li>官网: <a href="https://www.gnu.org/software/gdb/">https://www.gnu.org/software/gdb/</a></li>
<li>教程: <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></li>
</ul>
<p>GDB(GNU debugger)，是GNU软件系统中的标准调试器。支持C、C++等。</p>
<br/>
<br/>
<h3 id="pdb和ipdb">pdb和ipdb</h3>
<p>Pythone调试器:</p>
<ul>
<li>pdb: Python内建的调试器，用法与gdb一样。</li>
<li>ipdb: 一个开源的Python调试器，它和pdb有相同的接口，但是，它相对于pdb，具有语法高亮、tab补全、更友好的堆栈信息等高级功能。</li>
</ul>
<p>pdb是python的标准库，无需安装就可以使用。而ipdb是一个第三方库，需要使用pip安装。</p>
<p>这两个调试器有两种使用方法：</p>
<ul>
<li>一是集成在源代码中加入断点，但需要修改源码，麻烦。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">ipdb</span>

<span class="n">xxx</span>
<span class="n">ipdb</span><span class="o">.</span><span class="n">set_strace</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>二是交互式命令调试</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">python3 -m ipdb xxx.py
ipdb&gt;

ipdb&gt; <span class="nb">help</span>

Documented commands <span class="o">(</span><span class="nb">type</span> <span class="nb">help</span> &lt;topic&gt;<span class="o">)</span>:
<span class="o">========================================</span>
EOF    cl         disable  interact  next    psource  rv         unt
a      clear      display  j         p       q        s          <span class="k">until</span>
<span class="nb">alias</span>  commands   down     jump      pdef    quit     <span class="nb">source</span>     up
args   condition  <span class="nb">enable</span>   l         pdoc    r        step       w
b      cont       <span class="nb">exit</span>     list      pfile   restart  tbreak     whatis
<span class="nb">break</span>  <span class="k">continue</span>   h        ll        pinfo   <span class="k">return</span>   u          where
bt     d          <span class="nb">help</span>     longlist  pinfo2  retval   <span class="nb">unalias</span>
c      debug      ignore   n         pp      run      undisplay

Miscellaneous <span class="nb">help</span> topics:
<span class="o">==========================</span>
<span class="nb">exec</span>  pdb
</code></pre></td></tr></table>
</div>
</div><br>
<p><strong>ipdb常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>b/break</td>
<td>设置断点</td>
</tr>
<tr>
<td>tbreak</td>
<td>设置临时断点</td>
</tr>
<tr>
<td>cl/clear</td>
<td>清除断点</td>
</tr>
<tr>
<td>c/continue</td>
<td>继续执行程序</td>
</tr>
<tr>
<td>l/list</td>
<td>查看指定的代码行</td>
</tr>
<tr>
<td>ll/longlist</td>
<td>查看整个代码</td>
</tr>
<tr>
<td>s/step</td>
<td>执行会进入函数</td>
</tr>
<tr>
<td>n/next</td>
<td>执行不会进入函数</td>
</tr>
<tr>
<td>a</td>
<td>可列出当前函数的参数</td>
</tr>
<tr>
<td>r/return</td>
<td>执行代码直到从当前函数返回</td>
</tr>
<tr>
<td>j</td>
<td>忽略某段代码</td>
</tr>
<tr>
<td>pp</td>
<td>打印表达式的值</td>
</tr>
<tr>
<td>run/restart</td>
<td>重启，重启后断点、设置等会保留</td>
</tr>
<tr>
<td>q/quie/exit</td>
<td>中止并退出</td>
</tr>
<tr>
<td>h/help</td>
<td>帮助</td>
</tr>
</tbody>
</table>
<br>
<p>栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">python3 -m ipdb xxx.py
# 在第3行设置断点
ipdb&gt; b 3

# 执行到断点处
ipdb&gt; c

# 查看2-7行代码
ipdb&gt; l 2,7
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<hr>
<br/>
<br/>
<h1 id="编码">编码</h1>
<p>参考：</p>
<ul>
<li>ASCII: <a href="https://zh.wikipedia.org/wiki/ASCII">https://zh.wikipedia.org/wiki/ASCII</a></li>
<li>Unicode: <a href="https://zh.wikipedia.org/wiki/Unicode">https://zh.wikipedia.org/wiki/Unicode</a></li>
</ul>
<br>
<br>
<h2 id="unicode">Unicode</h2>
<p>计算机处理的是数字(二进制文件)。他们在存储字符时要给每个字符分配一个数值。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Utf8webgrowth.png"
        data-srcset="/images/Utf8webgrowth.png, /images/Utf8webgrowth.png 1.5x, /images/Utf8webgrowth.png 2x"
        data-sizes="auto"
        alt="/images/Utf8webgrowth.png"
        title="主要编码使用情况" /></p>
<br>
<p>早期的编码系统称为 ASCII（美国信息交换标准码）， 一共有128（0-127）个值，每个值用7bit 保存。ASCII可以满足小写、大写、数字标点符号和一些控制字符的处理。</p>
<p>人们曾尝试将ASCII字符扩展到8bit，这种新的被称为“扩充ASCII”的编码一直没有成为国际性标准。</p>
<br>
<p>为了克服ASCII和扩充ASCII先天上的不足，Unicode Consortiun（多语言软件生产商群体）创建了一种能够提供广泛字符集的通用编码系统，称为<strong>Unicode</strong>。</p>
<p>Unicode最初设置为2Byte的字符集。但版本3的Unicode用的是4Byte编码，并且与ASCII与扩充的ASCII完全兼容。</p>
<p>现在被称为Basic Latin（基本拉丁文）的ASCII字符集就是前25位全部置零的Unicode码。
现在被称为 Latin-1（拉丁文1）的扩充ASCII字符集就是前24位全部置零的Unicode码。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/unicode.png"
        data-srcset="/images/unicode.png, /images/unicode.png 1.5x, /images/unicode.png 2x"
        data-sizes="auto"
        alt="/images/unicode.png"
        title="Unicode兼容性" /></p>
<br>
<p>Unicode中的每个字符或符号由一个32bit数来定义，因此这种编码可以定义高达2的32次方(4 294 067 296)个字符或符号。
它的记法使用了十六进制数字，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">U-XXXXXXXX

#每个 X 都是一个十六进制的数字
#因此，它的数值从U-00000000到U-FFFFFFFF
</code></pre></td></tr></table>
</div>
</div><br>
<br>
<h2 id="ascii">ASCII</h2>
<p>美国信息交换码（American Standard Code of Information Internet，ASCII）是一种7bit码，设计来为128个大多数是美国英语里使用的符号提供编码。
今天的ASCII码已成为Unicode的一部分，它占据了Unicode中的前128个码（00000000-0000007F）。</p>
<p>ASCII的一些特点：</p>
<ul>
<li>space(20-sp)字符，是一个可打印的字符，打印出一个空格</li>
<li>大写字母从(41-A)开始，小写字母从(61-a)开始。按ASCII比较时，大写字母的数值会小于小写字母</li>
<li>大写字母与小写字母在他们的7bit编码中只有1bit不同，A(1000001)，a(1100001)，两者相差(20)十六进制</li>
<li>小写字母并没有紧跟在大写字母后面，这两者之间还有几个标点符号(5B-60)</li>
<li>数字从(30-0)开始</li>
<li>从00到1F这最开始的32个字符加上最后一个字符(7F)全都是非打印字符。字符(00)被用作定界符，已定义字符串的结束。字符(7F)是删除字符，它被某些编程语言用来删除前一个字符。剩下的非打印字符称为控制字符，用于数据通信</li>
</ul>
<br>
<p><strong>ASCII控制字符：</strong></p>
<p>二进制 | 十进制 | 十六进制 | 缩写 | Unicode<br>表示法 | 脱出字符<br>表示法 | 名称/意义</p>
<ul>
<li>| - | - | - | - | - | -
0000 0000 | 0 | 00 | NUL | ␀ | ^@ | 空字符（Null）
0000 0001 | 1 | 01 | SOH | ␁ | ^A | 标题开始
0000 0010 | 2 | 02 | STX |␂	| ^B	| 本文开始
0000 0011 | 3 | 03 | ETX | ␃ | ^C	| 本文结束
0000 0100 | 4 | 04 | EOT | ␄ | ^D	| 传输结束
0000 0101 | 5 | 05 | ENQ | ␅ | ^E	| 请求
0000 0110 | 6 | 06 | ACK | ␆ | ^F	| 确认回应
0000 0111 | 7 | 07 | BEL | ␇ | ^G	| 响铃
0000 1000 | 8 | 08 | BS	| ␈	| ^H	| 退格
0000 1001 | 9 | 09 | HT | ␉	| ^I	| 水平定位符号
0000 1010 | 10 | 0A	| LF | ␊ | ^J	| 换行键
0000 1011 | 11 | 0B	| VT | ␋ | ^K	| 垂直定位符号
0000 1100 | 12 | 0C	| FF | ␌ | ^L	| 换页键
0000 1101 | 13 | 0D	| CR | ␍ | ^M	| Enter键
0000 1110 | 14 | 0E	| SO | ␎ | ^N	| 取消变换（Shift out）
0000 1111 | 15 | 0F	| SI | ␏ | ^O	| 启用变换（Shift in）
0001 0000 | 16 | 10	| DLE | ␐ | ^P	| 跳出数据通讯
0001 0001 | 17 | 11	| DC1 | ␑ | ^Q	| 设备控制一（XON 激活软件速度控制）
0001 0010 | 18 | 12	| DC2 | ␒ | ^R	| 设备控制二
0001 0011 | 19 | 13	| DC3 | ␓ | ^S	| 设备控制三（XOFF 停用软件速度控制）
0001 0100 | 20 | 14	| DC4 | ␔ | ^T | 设备控制四
0001 0101 | 21 | 15	| NAK | ␕ | ^U	| 确认失败回应
0001 0110 | 22 | 16	| SYN | ␖ | ^V | 同步用暂停
0001 0111 | 23 | 17	| ETB | ␗ | ^W | 区块传输结束
0001 1000 | 24 | 18	| CAN | ␘ | ^X | 取消
0001 1001 | 25 | 19	| EM | ␙ | ^Y | 连接介质中断
0001 1010 | 26 | 1A	| SUB | ␚ | ^Z | 替换
0001 1011 | 27 | 1B	| ESC | ␛ | ^[ | 退出键
0001 1100 | 28 | 1C	| FS | ␜ | ^\ | 文件分区符
0001 1101 | 29 | 1D	| GS | ␝ | ^] | 组群分隔符
0001 1110 | 30 | 1E	| RS | ␞ | ^^ | 记录分隔符
0001 1111 | 31 | 1F	| US | ␟ | ^_ | 单元分隔符
0111 1111 | 127 | 7F | DEL| ␡ | ^? | 删除</li>
</ul>
<br>
<p><strong>ASCII可显示字符:</strong></p>
<p>进制 | 十进制 | 十六进制 | 图形</p>
<ul>
<li>| - | - | -
0010 0000 | 32 | 20 | (space)
0010 0001 | 33 | 21 | !
0010 0010 | 34 | 22 | &quot;
0010 0011 | 35 | 23 | #
0010 0100 | 36 | 24 | $
0010 0101 | 37 | 25 | %
0010 0110 | 38 | 26 | &amp;
0010 0111 | 39 | 27 | '
0010 1000 | 40 | 28 | (
0010 1001 | 41 | 29 | )
0010 1010 | 42 | 2A | *
0010 1011 | 43 | 2B | +
0010 1100 | 44 | 2C | ,
0010 1101 | 45 | 2D | -
0010 1110 | 46 | 2E | .
0010 1111 | 47 | 2F | /
0011 0000 | 48 | 30 | 0
0011 0001 | 49 | 31 | 1
0011 0010 | 50 | 32 | 2
0011 0011 | 51 | 33 | 3
0011 0100 | 52 | 34 | 4
0011 0101 | 53 | 35 | 5
0011 0110 | 54 | 36 | 6
0011 0111 | 55 | 37 | 7
0011 1000 | 56 | 38 | 8
0011 1001 | 57 | 39 | 9
0011 1010 | 58 | 3A | :
0011 1011 | 59 | 3B | ;
0011 1100 | 60 | 3C | &lt;
0011 1101 | 61 | 3D | =
0011 1110 | 62 | 3E | &gt;
0011 1111 | 63 | 3F | ?
0100 0000 | 64 | 40 | @
0100 0001 | 65 | 41 | A
0100 0010 | 66 | 42 | B
0100 0011 | 67 | 43 | C
0100 0100 | 68 | 44 | D
0100 0101 | 69 | 45 | E
0100 0110 | 70 | 46 | F
0100 0111 | 71 | 47 | G
0100 1000 | 72 | 48 | H
0100 1001 | 73 | 49 | I
0100 1010 | 74 | 4A | J
0100 1011 | 75 | 4B | K
0100 1100 | 76 | 4C | L
0100 1101 | 77 | 4D | M
0100 1110 | 78 | 4E | N
0100 1111 | 79 | 4F | O
0101 0000 | 80 | 50 | P
0101 0001 | 81 | 51 | Q
0101 0010 | 82 | 52 | R
0101 0011 | 83 | 53 | S
0101 0100 | 84 | 54 | T
0101 0101 | 85 | 55 | U
0101 0110 | 86 | 56 | V
0101 0111 | 87 | 57 | W
0101 1000 | 88 | 58 | X
0101 1001 | 89 | 59 | Y
0101 1010 | 90 | 5A | Z
0101 1011 | 91 | 5B | [
0101 1100 | 92 | 5C |<br>
0101 1101 | 93 | 5D | ]
0101 1110 | 94 | 5E | ^
0101 1111 | 95 | 5F | _
0110 0000 | 96 | 60 | `
0110 0001 | 97 | 61 | a
0110 0010 | 98 | 62 | b
0110 0011 | 99 | 63 | c
0110 0100 | 100 | 64 | d
0110 0101 | 101 | 65 | e
0110 0110 | 102 | 66 | f
0110 0111 | 103 | 67 | g
0110 1000 | 104 | 68 | h
0110 1001 | 105 | 69 | i
0110 1010 | 106 | 6A | j
0110 1011 | 107 | 6B | k
0110 1100 | 108 | 6C | l
0110 1101 | 109 | 6D | m
0110 1110 | 110 | 6E | n
0110 1111 | 111 | 6F | o
0111 0000 | 112 | 70 | p
0111 0001 | 113 | 71 | q
0111 0010 | 114 | 72 | r
0111 0011 | 115 | 73 | s
0111 0100 | 116 | 74 | t
0111 0101 | 117 | 75 | u
0111 0110 | 118 | 76 | v
0111 0111 | 119 | 77 | w
0111 1000 | 120 | 78 | x
0111 1001 | 121 | 79 | y
0111 1010 | 122 | 7A | z
0111 1011 | 123 | 7B | {
0111 1100 | 124 | 7C | l(管道线)
0111 1101 | 125 | 7D | }
0111 1110 | 126 | 7E | ~</li>
</ul>
<p>ASCII缺点：
ASCII的局限在于只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号。因此现在的软件系统大多采用Unicode。</p>
<br/>
<br/>
<h2 id="utf-8">UTF-8</h2>
<p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。</p>
<p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8的编码规则很简单，只有二条:</p>
<ol>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的</li>
<li>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码</li>
</ol>
<br/>
<br>
<hr>
<br/>
<h1 id="bash">Bash</h1>
<br>
<h2 id="bash与shell">bash与shell</h2>
<p>管理整个计算机硬件的其实是操作系统的内核(kernel)。这个内核是需要被保护的，所以一般用户就只能通过shell来跟内核通信，让内核达到我们想要达到的工作。</p>
<br>
<h3 id="硬件内核与shell">硬件、内核与shell</h3>
<p>我们必须通过shell，将我们输入的命令与内核通信，让内核可以控制硬件正确无误的工作。</p>
<p>操作系统其实是一组软件。由于这组软件在控制整个硬件与管理系统的活动监测，如果这组软件能被用户随意操作，若用户应用不当，将会使得整个系统奔溃。因为操纵系统管理的就是整个硬件功能，所以当然不能够被随便一些没有管理能力的终端用户随意使用。
但我们总是需要让用户操作系统的，所以就有了在操作系统上面发展的应用程序。用户可以通过应用程序来指挥内核，让内核达到我们所需要的硬件任务。</p>
<p>也就是说，只要能够操作应用程序的接口都能够称为shell。
狭义的shell指的是命令行方面的软件，包括bash等。广义的shell则包括图形界面的软件。</p>
<br/>
<h3 id="命令行shell">命令行shell</h3>
<ul>
<li>各Distribution的命令行界面都一样</li>
<li>远程管理非常快速</li>
<li>Linux的任督二脉</li>
</ul>
<br/>
<h3 id="系统合法shell与etcshells">系统合法shell与/etc/shells</h3>
<p>由于shell依据发布者的不同就有许多版本，例如Bourne SHell（sh）、C SHell、K SHell、TCSH等。</p>
<p>Linux默认使用的这一版本就是<strong>Bourne Again SHell(bash)</strong>，这个shell是Bourne SHell的增强版，也是基于GNU框架下发展出来的。</p>
<p>检查系统可用shell: <code>cat /etc/shells</code>
合法shell要写入<code>/etc/shells</code>，系统某些服务在运行过程中，会去检查用户能够使用的shell。</p>
<p>查看用户shell权限： <code>cat /etc/passwd</code>，最后一行便是默认shell。</p>
<br>
<h3 id="bash-shell">bash shell</h3>
<p>bash是GNU计划中重要的工具软件之一，目前也是Linux distributions 的标准shell。
bash主要兼容于sh，并且依据一些用户的需求而加强shell 版本。</p>
<p>bash的优点：</p>
<ul>
<li>命令记忆能力<code>history</code></li>
<li>命令与文件补全功能<code>tab</code></li>
<li>命令别名设置功能<code>alias</code></li>
<li>作业控制、前台、后台控制(job control, foreground, background)</li>
<li>使用前台、后台的控制可以让作业进行得更为顺利。至于作业控制(jobs)的用途更广，可以让我们随时将工作丢到后台中执行，而不怕不小心使用<code>ctrl+c</code>来中断该进程</li>
<li>程序脚本<code>shell  script</code></li>
<li>通配符(Wildcard)</li>
</ul>
<br>
<h3 id="type命令">type命令</h3>
<p><code>type</code>命令用于判断一个命令是內建命令还是外部命令(非bash提供)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ls


<span class="nb">type</span> -t ls
<span class="c1">#file，外部命令</span>
<span class="c1">#alias，别名</span>
<span class="c1">#builtin，內建命令</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br>
<h2 id="shell变量">shell变量</h2>
<p>变量就是以一组文字或符号等，来替代一些设置或者是一串保留的数据。</p>
<br>
<h3 id="变量显示与设置">变量显示与设置</h3>
<ul>
<li><code>echo</code>: 显示变量
<ul>
<li><code>echo $PATH</code></li>
</ul>
</li>
<li><code>unset</code>: 取消变量
<ul>
<li><code>unset $ZHANG</code></li>
</ul>
</li>
</ul>
<br>
<h3 id="变量设置规则">变量设置规则</h3>
<ul>
<li>变量与变量内容以一个等号<code>=</code>连接，如<code>myname=zhang</code></li>
<li>等号两边不能有空格符，否则错误</li>
<li>变量名称只能是英文字母和数字，开头字符不能是数字</li>
<li>变量内容若有空格，可使用双引号或单引号</li>
<li>双引号内的特殊符号，保有原本的特性</li>
<li>单引号内的特殊字符则仅为一般字符</li>
<li>转义字符<code>\\</code>，将特殊符号变成一般字符</li>
<li>在一串命令中，还需要使用其他命令，使用反单引号
<ul>
<li>反引号``内的命令将被优先执行，而其执行结果将作为外部的输入信息</li>
</ul>
</li>
<li>若该变量为了增加变量内容时，可用**$变量名称 **或**${变量}**累加内容
<ul>
<li><code>myname=${myname}xxx</code></li>
</ul>
</li>
<li>若该变量需要在其他子进程执行，请以<code>export</code>来使变量变成环境变量</li>
<li>通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断</li>
</ul>
<p>什么是子进程？在我目前这个shell下，去打开另一个新的shell。新的那个shell就是子进程。
在一般状态下，父进程定义的变量是无法在子进程内使用的，要通过<code>export</code>将变量变成环境变量后才可以。</p>
<br>
<p>注意<strong>单引号、双引号和反引号</strong>。</p>
<br>
<h3 id="环境变量">环境变量</h3>
<p>环境变量可以帮我们达到很多功能，包括主文件夹的变换、提示符的显示、执行文件查找的路径等。</p>
<ul>
<li><code>env</code>: 显示环境变量</li>
<li><code>set</code>: 查看所有变量
<ul>
<li>包括环境变量和自定义变量</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#HOME，用户主目录
#SHELL，当前环境使用的shell
#HISTSIZE，历史命令
#PATH，执行文件查找路径
#LANG，语系
#$PS1，命令提示符
#PS2，第二行提示符
</code></pre></td></tr></table>
</div>
</div><p>设置$PS1，$PS2:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">\d		#可显示出『星期 月 日』的日期格式，如：&#34;Mon Feb 2&#34;

\H		#完整的主机名

\h		#仅取主机名在第一个小数点之前的名字

\t		#显示时间，24小时格式的『HH:MM:SS』

\T		#显示时间，为12小时格式的『HH:MM:SS』

\A		#显示时间，为24小时格式的『HH:MM』

\@		#显示时间，为12小时格式的『am/pm』

\u		#目前使用者的账号名称，如『root』

\v		#BASH的版本信息

\w		#完整工作路径名，由根目录写起的目录名称。但家目录会以 ~ 取代

\W		#利用basename函数取得工作目录名称，所以仅会列出最后一个目录名。

\#		#下达的第几个命令

\$		#提示字符，root时，提示字符为#；否则就是$
</code></pre></td></tr></table>
</div>
</div><br>
<p><code>$</code>钱字号本身也是变量，代表当前shell的PID &ndash;&gt; <code>echo $$</code></p>
<p><code>?</code>问号也是一个特殊变量，代表上一个运行命令的回传值 &ndash;&gt; <code>echo $?</code></p>
<ul>
<li>0
<ul>
<li>命令运行成功</li>
</ul>
</li>
<li>errorcode
<ul>
<li>命令运行错误</li>
</ul>
</li>
</ul>
<br>
<h3 id="语系变量">语系变量</h3>
<p><code>locale</code> - get locale-specific information.</p>
<p>设置LANG的时候，其他的语系变量就会被这个变量所替代。</p>
<br>
<h3 id="变量键盘读取数组与声明">变量键盘读取、数组与声明</h3>
<ul>
<li><code>read</code>： 读取来自键盘输入的变量</li>
<li><code>declare</code>,<code>typeset</code>: 声明变量类型
<ul>
<li>变量的默认类型为字符串</li>
<li>若不指定变量类型，则<code>1+2</code>就是一个字符串而不是计算式</li>
</ul>
</li>
<li>数组变量类型
<ul>
<li>var[1]=&lsquo;varray1&rsquo;</li>
<li>var[2]=&lsquo;varray2&rsquo;</li>
<li>echo &ldquo;${${var[1]}, ${var[2]}}&rdquo;</li>
</ul>
</li>
</ul>
<br>
<br/>
<h2 id="bash-shell操作环境">bash shell操作环境</h2>
<p>自定义我们登录主机的时候屏幕上面会有一些说明文字，并且登录的时候还可以给用户提供一些信息或者欢迎文字，或环境变量和命令别名等。</p>
<br>
<h3 id="路径与命令查找顺序">路径与命令查找顺序</h3>
<p>命令的运行顺序：</p>
<ol>
<li>以绝对/相对路径执行命令</li>
<li>由alias找到该命令来执行</li>
<li>由bash内置的（builtin）命令来执行</li>
<li>通过$PATH这个变量的顺序找到的第一个命令来执行</li>
</ol>
<br>
<h3 id="bash登录与欢迎消息">bash登录与欢迎消息</h3>
<ul>
<li><code>/etc/issue</code> &ndash;&gt; 终端登录消息
<ul>
<li>CentOS Linux 7 (core)&hellip;..</li>
</ul>
</li>
<li><code>/etc/motd</code> &ndash;&gt; 用户登录后取得一些消息
<ul>
<li>Welcome to aliyun ECS</li>
</ul>
</li>
</ul>
<br/>
<h3 id="bash环境配置文件">bash环境配置文件</h3>
<p>操作系统有一些环境配置文件的存在，让bash在启动时直接读取这些配置文件，以规划好bash的操作环境。
这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。</p>
<p>命令别名、自定义的变量在你注销bash后就会失效。所以你想要保留你的设置，就得要将这些设置写入配置文件才行。</p>
<ul>
<li>login shell
<ul>
<li>取得bash需要完整的登录流程</li>
</ul>
</li>
<li>non-login shell
<ul>
<li>取得bash接口的方法不需要登录</li>
</ul>
</li>
</ul>
<br>
<h3 id="bash-shell快捷键">bash shell快捷键</h3>
<ul>
<li><code>Ctrl+C</code> &ndash;&gt; 终止当前命令</li>
<li><code>Ctri+D</code> &ndash;&gt; 输入结束(EOF)</li>
<li><code>Ctri+M</code> &ndash;&gt; Enter</li>
<li><code>Ctrl+S</code> &ndash;&gt; 暂停屏幕输出</li>
<li><code>Ctrl+Q</code> &ndash;&gt; 恢复屏幕输出</li>
<li><code>Ctrl+U</code> &ndash;&gt; 在提示字符下，将整列命令删除</li>
<li><code>Ctrl+Z</code> &ndash;&gt; 暂停目前命令</li>
</ul>
<br>
<h3 id="通配符与特殊符号">通配符与特殊符号</h3>
<p>通配符：</p>
<p>符号 | 说明</p>
<ul>
<li>| -</li>
</ul>
<ul>
<li>| 代表0-∞个 任意字符
? | 代表一定有一个 任意字符
[-] | 中括号内任一字符
[^] | 非中括号内字符</li>
</ul>
<p>bash常见特殊符号，理论上文件名不要用到上述字符。</p>
<p>符号 | 说明</p>
<ul>
<li>| -</li>
</ul>
<h1 id="-注释">| 注释</h1>
<p>\ | 转义字符
1 | 管道线
; | 连续命令分隔符
~ | 用户主目录
$ | 取变量前导符
&amp; | 将命令放入后台
! | 逻辑非
/ | 目录符号</p>
<blockquote>
<p>, &raquo; | 输出定向
&lt;, &laquo; | 输入定向
'' | 单引号
&quot;&quot; |　双引号
() | 子shell
{} | 命令区块混合</p>
</blockquote>
<br/>
<br>
<h2 id="重定向">重定向</h2>
<p>数据流重定向就是将某个命令执行后应该要出现在屏幕上的数据传输到其他的地方，如文件或设备。</p>
<ul>
<li>标准输入(stdin)，代码为0，使用<code>&lt;</code>或者<code>&lt;&lt;</code></li>
<li>标准输出(stdout)，代码为1，使用<code>&gt;</code>或者<code>&gt;&gt;</code></li>
<li>标准错误(stderr)，代码为2，使用<code>2&gt;</code>或者<code>2&gt;&gt;</code></li>
<li><code>&gt;</code>表示以覆盖方式写入，<code>&gt;&gt;</code>表示以追加方式写入</li>
</ul>
<br>
<br/>
<h2 id="管道">管道</h2>
<p>管道命令使用 &quot; | &quot; 这个界定符号。
管道命令&quot; | &quot; 仅能处理经由前面一个命令传来的正确信息。所以对stderror没有直接处理能力。</p>
<p>在每个管道后面接的第一个数据必定是命令，而且这个命令必须要能够接收standard input的数据才行，这样的命令才可以是管道命令。</p>
<br>
<br>
<hr>
<br/>
<h1 id="bash特殊符号">Bash特殊符号</h1>
<p>在编写shellscripts的时候，特殊符号也有其重要的功能。</p>
<br>
<p>符号  | 描述  | 栗子</p>
<ul>
<li>| -  | -
#!  |  shellban，申明脚本所使用的shell  | #!/bin/bash
\  | 转义字符  | \n
l  | 管道  | stdout l grep</li>
</ul>
<blockquote>
<p>,&raquo;  | 输出定向  | &gt; 1.txt
&lt;,&laquo;  | 输入定向  | &lt; 1.txt
2&gt;  | 错误定向  | 2&gt; error.txt
;  | 连续命令分隔符  | cmd1;cmd2
&amp;&amp;  | 与，只有当前命令完成后才执行后一个命令  | cmd1 &amp;&amp; cmd2
ll  | 或，或此或彼  | cmd1 ll cmd2
~ | 用户家目录  | cd ~</p>
</blockquote>
<h1 id="-注释符---comments">| 注释符  | #comments</h1>
<p>$  | 取用变量前导符 |  <code>$PATH</code>或<code>${PATH}</code>
&amp;  | 工作控制，将命令放入后台(bg)  | command&amp;</p>
<ul>
<li><br> ? <br/> [] <br/> [-] <br> [^]  | 通配符  | <em>.sh <br> ?.sh <br/> [a-z]</em>.txt <br/> [^zhang].txt
!  | 逻辑非  | !=
= 两边无空格  | 赋值符号  | <code>name=zhang</code>
= 两边有空格  | 比较符号  | <code>if  [ $name  =  zhang ]</code>
<code>$0</code> | 执行文件脚本名  | <code>/root/zhang.sh</code>
<code>$1</code>, <code>$2</code> | 第1,2个&hellip;变量  | <code>./zhang.sh start</code>
<code>$#</code>  | 参数个数  | <code>if [ $# -ne 2 ]；then echo 'Usage: $0 arg1 arg2'</code>
<code>$@</code>  | 代表<code>$1</code>,<code>$2</code>,<code>$3</code>&hellip;之意 | 每个变量是独立的
<code>$*</code>  | 代表<code>$1</code>c<code>$2</code>c<code>$3</code>&hellip;之意  | c为分割字符，默认为空格键
<code>$?</code>  | 命令状态码，成功为0  | <code>$?</code>
<code>$$</code>  | 当前shell的PID  | <code>echo $$</code>
&lsquo;单引号&rsquo;  |  单引号内特殊字符仅为一般字符  | <code>echo '$host'--$host</code>
&ldquo;双引号&rdquo;  | 双引号内特殊符号，可保有原本特性  | <code>echo &quot;$host&quot; --localhost</code>
`反引号`  | 运行命令 | 反引号内命令先执行
()  | 以子shell方式执行  | $(date)
{}  | 命令区块的组合  |
PS1  | 命令提示符  | $PS1
PS2  | 第二行以后的提示字符  | $PS2
<code>shift</code>  | 移动参数  | shift后面可以接数字，代表拿掉最前面的几个参数
<code>set</code>  |  查看所有变量  | <code>set</code>
<code>unset</code>  | 取消变量  | <code>unset name</code>，没有$符号
<code>export</code>  | 使某变量成为环境变量  | <code>export name</code>，没有$符号
<code>source</code> | source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录 | <code>source file</code></li>
</ul>
<br/>
<br>
<hr>
<br/>
<h1 id="shell脚本">shell脚本</h1>
<p>shell脚本有点像早期的批处理程序，即将一些命令汇整起来一次执行.但shell脚本拥有更强大的功能，可以进行类似程序(program)的编写，并且不需要经过编译(compile)就能执行。</p>
<br/>
<h2 id="介绍">介绍</h2>
<p>shell脚本是利用shell的功能写的一个程序(program)。这个程序是使用纯文本文件，将一些shell的语法与命令(含外部命令)写在里面，搭配正则表达式、命令管道与数据流重定向等功能，还提供了数组、循环、条件与逻辑判断等重要功能， 以达到我们所想要的处理目的。</p>
<p>shell脚本用在系统管理上面是很好的一项工具，但用在处理大量数值运算上就不够好。因为shell脚本的速度较慢，且使用的cpu资源较多，造成主机资源的分配不良。</p>
<br>
<p>使用shell脚本的优势：</p>
<ul>
<li>自动化管理的重要依据</li>
<li>追踪与管理系统的重要工具</li>
<li>简单入侵检测功能</li>
<li>连续命令单一化</li>
<li>简单的数据处理</li>
<li>跨平台支持与学习历程较短</li>
</ul>
<p>shell脚本注意事项：</p>
<ul>
<li>命令的执行是从上到下从左到右，分析与执行</li>
<li>命令的执行中：命令、参数间的多个空白都会被忽略掉</li>
<li>空白行也将被忽略，tab按键所得的空白同样视为空格键</li>
<li>读取到一个Enter符号(CR)，就尝试开始执行该行命令</li>
<li>一行内容太多，则可以使用<code>\[Enter]</code>来扩展到下一行</li>
<li>任何加在#后面的内容都将被视为注释而被忽略</li>
</ul>
<p>shell脚本文件的执行方式：</p>
<ul>
<li>直接命令执行
<ul>
<li><code>.sh</code>文件必须具有可读和可执行权限，使用绝对路径或相对路径来执行</li>
</ul>
</li>
<li>以bash进程来执行
<ul>
<li><code>bash xx.sh</code></li>
<li><code>sh xx.sh</code></li>
</ul>
</li>
</ul>
<p>shell脚本执行方式的区别：</p>
<ul>
<li>直接执行，脚本是在子进程的bash中执行的。当子进程完成后，子进程内的各项变量或操作将会结束而不会传回到父进程中。</li>
<li>source来执行，在父进程中执行</li>
</ul>
<br/>
<br>
<h2 id="编写一个shell脚本">编写一个shell脚本</h2>
<p>编写一个良好的shell脚本的技巧：</p>
<ul>
<li>脚本的功能</li>
<li>脚本的版本信息</li>
<li>脚本的作者</li>
<li>脚本的版权声明方式</li>
<li>脚本的历史记录</li>
<li>脚本内较特殊的命令，使用绝对路径的方式来执行</li>
<li>脚本执行时需要的环境变量预先声明与设置</li>
<li>在较为特殊的程序代码部分，建议务必要加上批注说明</li>
<li>脚本的退出状态码</li>
<li>对于一些字符串变量，使用括号引起来</li>
<li><code>set -e</code>会让脚本出错就停止运行</li>
<li><code>set -eu</code>会让脚本中有变量没有定义而退出</li>
<li>可以给变量定义默认值，如<code>${FOO:-'default'}</code></li>
<li>为脚本设置<code>-h</code>或<code>--help</code>来显示帮助信息，千万别把这两个参数作为功能</li>
<li>使用<code>$()</code>而非反引号来获得命令行的输出，主要是易读</li>
<li>一定要小心使用<code>rm -rf</code>这样的命令。比如<code>rm -rf $MYDIDR/*</code>，如果<code>$MYDIR</code>为空，结果是灾难性的</li>
<li>考虑使用<code>find/while</code>而不是<code>for/find</code></li>
<li>防御式编程，在正式执行命令前，把相关的东西都检查好</li>
<li>学会使用<code>grep/awk/sed</code>这些命令</li>
<li>检查命令是否存在，不建议用<code>which</code>，因为它没有设置状态码。建议使用<code>hash/type</code>。</li>
</ul>
<br>
<br/>
<h2 id="shell脚本判断式">shell脚本判断式</h2>
<p>当我要检测系统上某些文件或相关属性时，使用<code>test</code>命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">test</span> -e /root/test.txt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">&#39;Exist&#39;</span> <span class="o">||</span> <span class="s1">&#39;Not exist&#39;</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<p><strong>文件类型判断</strong>：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>是否存在文件</td>
</tr>
<tr>
<td>-d</td>
<td>是否存在目录</td>
</tr>
<tr>
<td>-b</td>
<td>是否存在block device</td>
</tr>
<tr>
<td>-c</td>
<td>是否存在character device</td>
</tr>
<tr>
<td>-S</td>
<td>是否存在Socket文件</td>
</tr>
<tr>
<td>-p</td>
<td>是否存在pipe文件</td>
</tr>
<tr>
<td>-L</td>
<td>是否存在链接文件</td>
</tr>
</tbody>
</table>
<br/>
<p><strong>文件权限判断</strong>：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>是否可读</td>
</tr>
<tr>
<td>-w</td>
<td>是否可写</td>
</tr>
<tr>
<td>-x</td>
<td>是否可执行</td>
</tr>
<tr>
<td>-u</td>
<td>是否具有SUID</td>
</tr>
<tr>
<td>-g</td>
<td>是够具有SGID</td>
</tr>
<tr>
<td>-k</td>
<td>是否具有Sticky bit</td>
</tr>
<tr>
<td>-s</td>
<td>是否为非空白文件</td>
</tr>
</tbody>
</table>
<br/>
<p><strong>文件之间的比较</strong>：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-nt</td>
<td>newer than</td>
</tr>
<tr>
<td>-ot</td>
<td>old than</td>
</tr>
<tr>
<td>-ef</td>
<td>是否为同一个文件</td>
</tr>
</tbody>
</table>
<br>
<p><strong>整数之间的比较</strong>：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>equal</td>
</tr>
<tr>
<td>-ne</td>
<td>not equal</td>
</tr>
<tr>
<td>-gt</td>
<td>greater than</td>
</tr>
<tr>
<td>-lt</td>
<td>less than</td>
</tr>
<tr>
<td>-ge</td>
<td>greater or equal</td>
</tr>
<tr>
<td>-le</td>
<td>less or equal</td>
</tr>
</tbody>
</table>
<br/>
<p><strong>字符串之间的比较</strong>：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-z</td>
<td>是否为空</td>
</tr>
<tr>
<td>-n</td>
<td>非空</td>
</tr>
<tr>
<td>str1 = str2</td>
<td>是否相等</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
</tbody>
</table>
<br>
<p><strong>多重条件判断</strong>：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>and</td>
</tr>
<tr>
<td>-o</td>
<td>or</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
</tr>
</tbody>
</table>
<br/>
<p><strong>判断符号[]</strong>:</p>
<p>如果需要在bash中使用中括号来作为shell的判断式时，必须要注意中括号的两端需要有空格符来分隔。</p>
<ul>
<li>中括号内的变量，每个最好都用双引号括起来</li>
<li>中括号内的常量，最好都以单或双引号括起来</li>
</ul>
<br/>
<br>
<h2 id="shell脚本的默认变量">shell脚本的默认变量</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 示例</span>
/root/test.sh opt1 opt2 opt3
	<span class="nv">$0</span>	<span class="nv">$1</span>	<span class="nv">$2</span>	<span class="nv">$3</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>执行文件的脚本名就是$0</li>
<li>文件后接的第一个参数就是$1，以此类推</li>
<li>$#，表示参数个数</li>
<li>$@，表示&quot;$1&quot;, &ldquo;$2&rdquo;&hellip;</li>
<li><code>shift</code>，参数变量号码偏移
<ul>
<li><code>shift n</code>，代表拿掉前面几个参数的意思</li>
</ul>
</li>
</ul>
<br>
<br/>
<h2 id="条件判断语句">条件判断语句</h2>
<br>
<h3 id="ifthen语句">if&hellip;then语句</h3>
<p>if&hellip;then 是最常见的条件判断式。</p>
<p>单层条件判断：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">if</span> <span class="o">[</span> confition <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    xxx
<span class="k">fi</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p>多层条件判断：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">if</span> <span class="o">[</span> condition <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
	xxx<span class="p">;</span>
<span class="k">else</span>
	xxx<span class="p">;</span>
<span class="k">fi</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">if</span> <span class="o">[</span> confition1 <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
	xxx<span class="p">;</span>
<span class="k">elif</span> <span class="o">[</span> condition2 <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
	xxx<span class="p">;</span>
<span class="k">else</span>
	xxx<span class="p">;</span>
<span class="k">fi</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h3 id="caseesac语句">case&hellip;esac语句</h3>
<p>有多个既定变量内容，那么只需要针对这几个变量来设置状况就好。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">case</span> $变量名 in
<span class="s2">&#34;</span><span class="nv">$var1</span><span class="s2">&#34;</span><span class="o">)</span>
	xxx
    <span class="p">;;</span>
<span class="s2">&#34;</span><span class="nv">$var2</span><span class="s2">&#34;</span><span class="o">)</span>
	xxx
    <span class="p">;;</span>
*<span class="o">)</span>
	xxx
    <span class="p">;;</span>
<span class="k">esac</span>



<span class="c1">####栗子</span>
<span class="c1">#/etc/init.d/network</span>

<span class="k">case</span> <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span> in
start<span class="o">)</span>
	xxx
	<span class="p">;;</span>
stop<span class="o">)</span>
	xxx
    <span class="p">;;</span>
restart<span class="o">)</span>
	xxx
    <span class="p">;;</span>
status<span class="o">)</span>
	xxx
    <span class="p">;;</span>
<span class="k">esac</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h3 id="function功能">function功能</h3>
<p>什么是函数？函数可以在shell脚本当中做出一个类似自定义执行命令的东西。最大的动能是，可以简化很多的程序代码。</p>
<p>因为shell脚本的执行方式是由上而下、由左而右。因此在shell脚本当中，function的定义一定要在程序的最前面，这样才能够在执行时被找到可用的程序段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">vim func.sh



<span class="k">function</span> fname <span class="o">()</span> <span class="o">{</span>

<span class="o">}</span>


<span class="c1">####栗子</span>
<span class="k">function</span> Zhang<span class="o">()</span> <span class="o">{</span>
	<span class="nb">echo</span> <span class="nv">$1</span> <span class="nv">$2</span>
<span class="o">}</span>

Zhang <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2">&#34;</span>



<span class="c1">#执行</span>
sh func.sh aaa bbb
</code></pre></td></tr></table>
</div>
</div><br>
<br>
<h2 id="循环语句">循环语句</h2>
<br>
<h3 id="while-do-done不定循环">while do done(不定循环)</h3>
<p><code>while</code>是当condition条件成立时，就进行循环，condition条件不成立就停止。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">while</span> <span class="o">[</span> condition1 <span class="o">]</span>
<span class="k">do</span>
	xxx
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h3 id="until-do-done不定循环">until do done(不定循环)</h3>
<p><code>until</code>是当condition条件成立时，终止循环；否则就持续进行循环的循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">until</span> <span class="o">[</span> condition <span class="o">]</span>
<span class="k">do</span>
	xxx
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h3 id="for-do-done固定循环">for do done(固定循环)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">for</span> i in con1 con2 con3 ...
<span class="k">do</span>
	xxx
<span class="k">done</span>


<span class="c1">####栗子</span>
<span class="k">for</span> i in 192.168.1.<span class="o">{</span>1,2,3<span class="o">}</span>
<span class="k">do</span>
	ping -c <span class="m">1</span> <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<p><code>for do done</code>的数值处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">for</span> <span class="o">((</span>初始值<span class="p">;</span>限制值；步长<span class="o">))</span>
<span class="k">do</span>
	xxx
<span class="k">done</span>


<span class="c1">####栗子</span>
<span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>0<span class="p">;</span>i&lt;10<span class="p">;</span>i++<span class="o">))</span>
<span class="k">do</span>
	<span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h2 id="shell脚本的追踪与调试">shell脚本的追踪与调试</h2>
<p>最好在shell脚本执行之前先行调试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">sh <span class="o">[</span>-nvx<span class="o">]</span> xxx.sh


<span class="c1">#-v 运行脚本前，先将脚本内容输入到屏幕</span>
<span class="c1">#-n 仅查询语法问题</span>
<span class="c1">#-x 边显示边执行</span>

当然也可以把这几个调试参数写到shellbang中
<span class="c1">#!/bin/bash -x</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<hr>
<br>
<h1 id="小试牛刀">小试牛刀</h1>
<h2 id="简介-1">简介</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#bash(Bourne Again Shell)，shell环境使得用户能与操作系统的内核进行交互操作</span>

<span class="c1">#!/bin/bash</span>
<span class="c1">#date</span>
<span class="c1">#description</span>

cmd1<span class="p">;</span> cmd2
cmd3


<span class="c1">#sh /path/xx.sh</span>
<span class="c1">#Bash还有一个历史记录文件 ~/.bash_history</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="终端打印echo">终端打印(<code>echo</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#终端作为交互式工具，用户可以通过它与shell环境进行交互</span>

<span class="nb">echo</span> <span class="s1">&#39;$var&#39;</span>
<span class="nb">echo</span> <span class="nv">$var</span>
<span class="nb">echo</span> -e <span class="s2">&#34;1\t2\t3&#34;</span>
<span class="nb">echo</span> -e <span class="s1">&#39;\e[1;31m Red color \e[0m&#39;</span>    <span class="c1">#彩色</span>


<span class="nb">echo</span> <span class="o">{</span>1..10<span class="o">}</span>		<span class="c1">#输出1到10</span>
<span class="nb">echo</span> <span class="o">{</span>A..H<span class="o">}</span>		<span class="c1">#for i in {a..z}</span>


cat <span class="s">&lt;&lt; EOF
</span><span class="s">11
</span><span class="s">22
</span><span class="s">33
</span><span class="s">EOF</span>


<span class="c1"># \转义字符</span>
<span class="nb">printf</span> <span class="s2">&#34;%-5s %-10s </span><span class="nv">$-</span><span class="s2">4.2f\n&#34;</span> <span class="m">001</span> Zhang 56.789
<span class="c1">#格式替代符%s %d %c %f, -左对齐</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="玩转变量和环境变量">玩转变量和环境变量</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#Bash中，每一个变量默认值值都是字符串形式</span>
<span class="c1">#环境变量和自定义变量</span>

<span class="nb">echo</span> <span class="nv">$SHELL</span>
<span class="nb">echo</span> <span class="nv">$UID</span>


<span class="nv">var</span><span class="o">=</span>value	<span class="c1">#这是赋值</span>
<span class="c1">#var = value这是相等操作</span>
<span class="nb">echo</span> <span class="nv">$var</span>
<span class="nb">echo</span> <span class="si">${</span><span class="nv">var</span><span class="si">}</span>
<span class="nb">echo</span> <span class="si">${#</span><span class="nv">var</span><span class="si">}</span>	<span class="c1">#字符数</span>


<span class="c1">#export用来设置环境变量，此后，任何shell中的程序都会继承环境变量</span>
<span class="nv">ZHANG</span><span class="o">=</span>Gentleman
<span class="nb">export</span> ZHANG


<span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$PATH</span><span class="s2">:/home/zhang/bin&#34;</span>
<span class="nb">export</span> <span class="nv">$PATH</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="通过shell进行数学运算">通过shell进行数学运算</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#let, expr, bc, [], (())</span>
<span class="c1">#要注意默认是字符串类型哦</span>

<span class="nv">n1</span><span class="o">=</span>1<span class="p">;</span><span class="nv">n2</span><span class="o">=</span><span class="m">2</span>
<span class="nb">let</span> <span class="nv">sum</span><span class="o">=</span>n1+n2
<span class="nb">let</span> n1++<span class="p">;</span><span class="nb">let</span> n2-<span class="o">=</span><span class="m">1</span>

<span class="nv">sum</span><span class="o">=</span>$<span class="o">[</span> n1 + n2 <span class="o">]</span>
<span class="nv">sum2</span><span class="o">=</span><span class="k">$((</span> sum <span class="o">+</span> <span class="m">3</span> <span class="k">))</span>

<span class="nv">sum</span><span class="o">=</span><span class="sb">`</span>expr <span class="m">3</span> + 4<span class="sb">`</span>


<span class="c1">#浮点计算 bc</span>
<span class="nb">echo</span> <span class="s2">&#34;8 * 1.1&#34;</span> <span class="p">|</span> bc


<span class="c1">#设置小数点精度</span>
<span class="nb">echo</span> <span class="s2">&#34;scale=2; 3/8&#34;</span> <span class="p">|</span> bc


<span class="c1">#进制转换</span>
<span class="nv">num</span><span class="o">=</span><span class="m">100</span>
<span class="nb">echo</span> <span class="s2">&#34;obase=2; </span><span class="nv">$num</span><span class="s2">&#34;</span> <span class="p">|</span> bc

<span class="nv">num</span><span class="o">=</span><span class="m">1100100</span>
<span class="nb">echo</span> <span class="s2">&#34;obase=10; ibase=2; </span><span class="nv">$num</span><span class="s2">&#34;</span> <span class="p">|</span> bc


<span class="c1">#平方和平方根</span>
<span class="nb">echo</span> <span class="s2">&#34;sqrt(100)&#34;</span> <span class="p">|</span> bc
<span class="nb">echo</span> <span class="s2">&#34;10^2&#34;</span> <span class="p">|</span> bc
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="文件描述符重定向">文件描述符重定向</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#最常用的文件描述符是 stdin(0), stdout(1), stderr(2); 通过内容过滤将输出重定向到文件</span>

<span class="nb">echo</span> <span class="s2">&#34;This is a sample text 1&#34;</span> &gt; temp.txt	<span class="c1">#覆盖</span>
<span class="nb">echo</span> <span class="s2">&#34;This is sample text 2&#34;</span> &gt;&gt; temp.txt	<span class="c1">#追加</span>

ls + &gt;stdout.txt 2&gt;stderr.txt
cmd 2&gt;<span class="p">&amp;</span><span class="m">1</span> /dev/null  <span class="o">==</span> com <span class="p">&amp;</span>&gt; /dev/null		<span class="c1">#null设备也被称为黑洞</span>


<span class="c1">#当一个command发生错误并退回时，它会返回一个非0的状态码</span>
<span class="nb">echo</span> <span class="nv">$?</span>


<span class="c1">#tee命令，一方面可将数据重定向到文件，另一方面还可提供一份重定向数据的副本作为后续命令的stdin</span>
<span class="c1">#tee默认覆盖文件，-a选项追加</span>
cat temp.txt <span class="p">|</span> tee tee.txt <span class="p">|</span> cat -n
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="数组和关联数组">数组和关联数组</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#数组借助索引将多个独立的数据存储为一个集合</span>
<span class="c1">#普通数组只能使用整数作为数组索引，而关联数组可以使用字符串作为数组索引</span>
<span class="c1">#还可将数组定义成一组索引-值(index-value)</span>


<span class="nv">arr</span><span class="o">=(</span><span class="m">1</span> two <span class="m">3</span> four 5<span class="o">)</span>
<span class="nb">echo</span> <span class="si">${</span><span class="nv">arr</span><span class="p">[0]</span><span class="si">}</span>
arr<span class="o">[</span>0<span class="o">]=</span>One


<span class="nv">index</span><span class="o">=</span><span class="m">3</span>
<span class="nb">echo</span> <span class="si">${</span><span class="nv">arr</span><span class="p">[</span><span class="nv">$index</span><span class="p">]		#arr[3]
</span><span class="p">echo </span><span class="si">${</span><span class="nv">arr</span><span class="p">[*]</span><span class="si">}</span><span class="p">
</span><span class="p">echo </span><span class="si">${#</span><span class="nv">arr</span><span class="p">[*]</span><span class="si">}</span><span class="p">		#arr-length
</span><span class="p">
</span><span class="p">
</span><span class="p">#关联数组可用任意文本作为数组索引
</span><span class="p">declare -A ass_arr
</span><span class="p">ass_arr=([index1]=val1 [index2]=val2 ...)	#内嵌索引-值
</span><span class="p">ass_arr[index3]=val3	#独立索引-值
</span><span class="p">echo </span><span class="si">${</span><span class="p">!ass_arr[*]</span><span class="si">}</span><span class="p">		#列出数组索引
</span></code></pre></td></tr></table>
</div>
</div><br>
<h2 id="别名alias">别名(<code>alias</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#alias作用是暂时的，关闭终端后别名就失效；</span>
<span class="c1">#为使别名一直保持，可将其写入 ~/.bashrc，因为每一个新的shell都会执行~/.bashrc中的命令</span>
<span class="c1">#新设置的别名将取代已有别名</span>


<span class="nb">alias</span> <span class="nv">vi</span><span class="o">=</span>vim<span class="p">;</span>
<span class="nb">unalias</span> vi
<span class="nb">echo</span> <span class="s2">&#34;alias ll=&#39;ls -l --color=auto&#39;&#34;</span> &gt;&gt; ~/.bashrc


<span class="c1">#\对别名命令进行转义，执行原本的命令。避免攻击者利用别名将某些特权命令替换成别有用心的命令</span>
<span class="se">\v</span>i test.sh
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="获取设置日期和延时date">获取、设置日期和延时(<code>date</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#很多应用程序需要以不同的格式打印日期，设置日期和时间，以及根据日期和时间执行操作;</span>
<span class="c1">#延时通常用于在程序执行过程中提供一段等待时间;</span>
<span class="c1">#在Unix-like系统中，日期被存储为一个整数，其大小为世界标准时间1970年1月1日0时0分0秒起所流逝的秒数；</span>
<span class="c1">#这种计时方式被称之为 纪元时或Unix时间；</span>
<span class="c1">#通过纪元时间，可知道两个日期之间相隔了多少秒</span>
<span class="c1">#编写以循环方式运行的监视脚本时，设置时间间隔是必不可少的</span>

date +%s

<span class="c1">#!/bin/bash</span>
<span class="nv">start</span><span class="o">=</span><span class="k">$(</span>date +%s<span class="k">)</span>
commands
sleep <span class="m">1</span>
<span class="nv">end</span><span class="o">=</span><span class="k">$(</span>date +%s<span class="k">)</span>
<span class="nv">diff</span><span class="o">=</span><span class="k">$((</span>end <span class="o">-</span> start<span class="k">))</span>
<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$diff</span><span class="s2"> seconds&#34;</span>


<span class="c1">#显示指定时间</span>
date +%F -d -1days
date +%H -d -3hours



<span class="c1">#将标准时间转换为原子时间</span>
date -d <span class="s1">&#39;2018-02-07 14:05:53&#39;</span> +%s
<span class="m">1517983553</span>

<span class="c1">#将原子时间转换为标准时间</span>
date --date<span class="o">=</span><span class="s1">&#39;@1517983553&#39;</span>
Wed Feb  <span class="m">7</span> 14:05:53 CST <span class="m">2018</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="调试脚本sh">调试脚本(<code>sh</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#调试功能能在出现一些异常情况时生成运行信息</span>

<span class="c1">#!/bin/bash -xv</span>
sh -x
sh -n
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="函数和参数function">函数和参数(<code>function</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">function</span> fname<span class="o">()</span>
<span class="o">{</span>
statements
<span class="o">}</span>


fname<span class="o">()</span>
<span class="o">{</span>
<span class="nb">echo</span> <span class="nv">$1</span>, <span class="nv">$2</span>		<span class="c1">#访问第参数1和参数2,$n第n个参数</span>
<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>		<span class="c1">#以列表的形式一次性打印所有参数</span>
<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$*</span><span class="s2">&#34;</span>		<span class="c1">#类似于$@，但参数被作为单个实体</span>
<span class="k">return</span> 0		<span class="c1">#f返回值</span>
<span class="o">}</span>
fname <span class="m">1</span> <span class="m">22</span> 333	<span class="c1">#返回上面定义的变量</span>


<span class="c1">#递归函数，能够调用自身，不断地生成新的进程，最终会造成xx</span>
<span class="c1">#导出函数，使用export导出，这样函数作用域就可以扩展到子进程</span>
<span class="nb">export</span> -f fname
<span class="c1">#读取命令返回值</span>
<span class="nb">echo</span> <span class="nv">$?</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="读取命令序列输出---">读取命令序列输出(` `, $() )</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#输入通常是stdin，输出stderr或stdout,这些命令称为 过滤器(filter)。我们使用 管道(pipe) 来连接每一个过滤器</span>
cmd1 <span class="p">|</span> cmd2 <span class="p">|</span> cmd3


<span class="c1">#子shell，子shell生成独立的进程，不会对当前shell有任何影响，所做改变仅限于子shell内</span>
<span class="nv">zhang</span><span class="o">=</span><span class="k">$(</span>ls <span class="p">|</span> cat -n<span class="k">)</span>


<span class="c1">#反引用</span>
<span class="nv">zhang</span><span class="o">=</span><span class="sb">`</span>ls <span class="p">|</span> cat -n<span class="sb">`</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="读取字符read">读取字符(<code>read</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#read是一个重要的从标准输入中读取文本的命令</span>
<span class="c1">#可以使用read以交互的形式来读取用户的输入</span>

<span class="nb">read</span> -n <span class="m">5</span> zhang		<span class="c1">#读取字符数</span>
<span class="nb">echo</span> <span class="nv">$zhang</span>

<span class="nb">read</span> -s passwd		<span class="c1">#不回显</span>
<span class="nb">echo</span> <span class="nv">$passwd</span>

<span class="nb">read</span> -t <span class="m">5</span> zhang		<span class="c1">#超时时间</span>
<span class="nb">echo</span> <span class="nv">$zhang</span>

<span class="nb">read</span> -p zhang		<span class="c1">#显示提示信息</span>
<span class="nb">echo</span> <span class="nv">$zhang</span>

<span class="nb">read</span> -d <span class="s2">&#34;:&#34;</span> zhang		<span class="c1">#定界符结束输入</span>
123：
<span class="nb">echo</span> <span class="nv">$zhang</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="字段分隔符和迭代器">字段分隔符和迭代器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#内部字段分隔符(Internal Field Separator, IFS)是shell中的一个重要概念</span>
<span class="c1">#IFS的默认值为空白字符(换行符、制表符、空格)</span>
awk -F: <span class="s1">&#39;{print $1,$3}&#39;</span> /etc/passwd		<span class="c1">#IFS=&#34;:&#34;</span>

<span class="c1">#对一些列值进行迭代，循环非常有用</span>
<span class="k">for</span> i in <span class="o">{</span>1..10<span class="o">}</span>
<span class="k">do</span>
cmd
<span class="k">done</span>

<span class="k">while</span> condition
<span class="k">do</span>
cmd
<span class="k">done</span>

<span class="k">until</span> condition
<span class="k">do</span>
cmd
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="比较与测试">比较与测试</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#程序中的流程控制是由比较和测试语句来处理的</span>
<span class="k">if</span> condition1 <span class="o">||</span> condition2
<span class="k">then</span>
	cmd1
<span class="k">elif</span> condition3 <span class="o">&amp;&amp;</span> condition4
<span class="k">then</span>
	cmd2
<span class="k">else</span>
	cmd3
<span class="k">fi</span>


<span class="c1">#算术比较</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$num</span> -ge <span class="m">10</span> -a <span class="nv">$num</span> -lt <span class="m">20</span> <span class="o">]</span>

-eq
-gt
-ge
-lt
-le
-a
-o


<span class="c1">#文件系统相关</span>
<span class="k">if</span> <span class="o">[</span> -f <span class="nv">$file1</span> -o -x <span class="nv">$file2</span><span class="o">]</span>

-x
-w
-r
-f
-d
-e
-b		<span class="c1">#block</span>
-l


<span class="c1">#字符串比较</span>
<span class="o">[[</span> <span class="nv">$str1</span> <span class="o">=</span> <span class="nv">$str2</span><span class="o">]]</span>

<span class="o">=</span>		<span class="c1">#=号旁有空格--是比较关系；=号旁没空格，是赋值语句</span>
!<span class="o">=</span>
&gt;
&lt;
-z		<span class="c1">#空字符</span>
-n		<span class="c1">#非空字符</span>


<span class="c1">#使用test命令来执行条件检测</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$num</span> -eq <span class="m">0</span> <span class="o">]</span>  -- <span class="k">if</span> <span class="nb">test</span> <span class="nv">$num</span> -eq <span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h1 id="命令之乐">命令之乐</h1>
<h2 id="简介-2">简介</h2>
<p>各种命令可谓Unix-Like系统中优美的部分，它能帮我们搞定各种繁杂的任务。
一旦你尝试过Linux提供的这些利器，你一定会感到惊讶：以前没有这些命令的时候，自己是什么熬过来的。
最钟爱的莫过于 <code>grep</code>, <code>awk</code>, <code>sed</code>, <code>find</code> 命令了！</p>
<p>本章将会为你介绍一些最有趣同时也是最实用的命令。</p>
<br>
<h2 id="用cat进行拼接">用<code>cat</code>进行拼接</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#cat命令通常用于读取、显示或拼接文件内容，不过它所具备的能力远不止此</span>
<span class="c1">#cat(concatenate, 拼接)</span>
cat file1 file2 ···
<span class="nb">echo</span> <span class="s2">&#34;Ahaha&#34;</span> <span class="p">|</span> cat - file1 file2		<span class="c1">#-指stdin文本文件名</span>

cat -s file3  -- cat file3 <span class="p">|</span> tr -s <span class="s1">&#39;\n&#39;</span>		<span class="c1">#压缩空白行</span>
cat -T test.py		<span class="c1">#将制表符显示为 ^I, 避免制表符和连续空格误用, 产生错误缩进</span>
cat -n file4		<span class="c1">#显示行号</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="录制与回放终端会话script">录制与回放终端会话(<code>script</code>)</h2>
<p>当你需要准备一个命令行教程时，如果将我们输入命令后的一切按照先后次序记录下来，再进行回放，是不是很nice！
通过 <code>script</code>, <code>scriptreplay</code> 命令, 把终端会话记录到文件，并回放。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#-t,将时间数据输出到标准错误； -a,追加输出</span>
script -t 2&gt; timing.log -a output.session		<span class="c1">#两个文件随意取名, 如不将错误重定向会显示在屏幕上导致很乱</span>
输入命令
cmd2
···
<span class="nb">exit</span>		<span class="c1">#退出录制</span>


scriptreplay -t timing.log output.session		<span class="c1">#播放</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="文件查找与文件列表find">文件查找与文件列表(<code>find</code>)</h2>
<p><code>find</code> 是Unix/Linux命令行工具箱中最棒的工具之一。
<code>find</code> 命令沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。</p>
<p>find - search for files in a directory hierarchy</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#基于文件名及正则表达式搜索</span>
find /home/zhang		<span class="c1">#列出/home/zhang目录及其子目录线所有文件和文件夹</span>
find /home/zhang -name <span class="s2">&#34;*.txt&#34;</span>
find . -name <span class="s2">&#34;*.sh&#34;</span> -o -iname <span class="s2">&#34;zhang*&#34;</span>		<span class="c1">#匹配多个</span>
find /home/zhang -path <span class="s2">&#34;201710*&#34;</span>		<span class="c1">#-path将文件路径作为一个整体进行匹配</span>
find . -regex	<span class="s2">&#34;.*\(\.txt|\.[0-9]+\)</span>$<span class="s2">&#34;</span>		<span class="c1">#匹配以.txt或数字结尾的文件</span>



<span class="c1">#使用-maxdepth, -mindepth参数，来限制find的遍历深度</span>
<span class="c1">#-type, 根据文件类型搜索。 f(普通文件)，d(目录)，b(块设备)，l(符号链接)，s(套接字)等</span>
find /home -maxdepth <span class="m">1</span> -type f<span class="o">(</span>d<span class="o">)</span>		<span class="c1">#参数顺序也会影响find的查找效率</span>



<span class="c1">#根据文件类型搜索</span>
find /dev -type b		<span class="c1">#查看/dev及其子目录下设备文件</span>
find / -maxdepth <span class="m">1</span> -type l		<span class="c1">#查找/下链接文件</span>



<span class="c1">#根据文件时间进行搜索</span>
<span class="c1">#Unix/Linux文件系统中的每一个文件都有三种时间戳(timestamp),-表示小于，+表示大于</span>
<span class="c1">#Unix中并没有所谓的 &#34;创建时间&#34; 的概念</span>
<span class="c1">#访问时间(-atime,以天为单位； -amin,以分钟为单位):用户最近一次访问文件时间；</span>
<span class="c1">#修改时间(-mtime,以天为单位； -mmin,以分钟为单位):文件最后一次修改时间；</span>
<span class="c1">#变化时间(-ctime,以天为单位； -cmin,以分钟为单位):文件元数据(如权限，所有权)最后一次变化时间；</span>
find /home/zhang -type f -mtime 7		<span class="c1">#7天前被修改的普通文件</span>
find /home/zhang -type f -amin -10		<span class="c1">#搜索10分钟内被修改的普通文件</span>
find . -type f -newer file1.txt		<span class="c1">#找出比file1.txt新的文件</span>



<span class="c1">#基于文件大小的搜索</span>
<span class="c1">#b(块，512字节), c(字节), w(字，2字节), k(千字节), M(兆字节), G(吉字节)</span>
find . -type -f -size +100k



<span class="c1">#删除匹配的文件</span>
find . -type f -name <span class="s2">&#34;*.swp&#34;</span> -delete



<span class="c1">#基于文件权限和所有权的匹配</span>
find . -type f -perm <span class="m">644</span>
find /var/apache -type f -name <span class="s2">&#34;*.php&#34;</span> -perm 644		<span class="c1">#搜索基于权限的文件</span>
find /var -maxdepth <span class="m">2</span> -type f -user zhang		<span class="c1">#搜索基于用户的文件</span>



<span class="c1">#执行命令或动作</span>
<span class="c1">#find命令可以借助-exec与其他命令进行结合</span>
<span class="c1">#{}是一个特殊字符串，将替换为相应文件名</span>
find . -type f -perm <span class="m">764</span> -user zhang -exec chmod <span class="m">644</span> <span class="o">{}</span> <span class="se">\;</span>		<span class="c1">#将所属用户zhang，权限764的文件权限修改为644</span>
find . -type f -mmin +30 -name <span class="s2">&#34;*.txt&#34;</span> -exec cp <span class="o">{}</span> <span class="o">{}</span>.old <span class="se">\;</span>		<span class="c1">#复制最近30内修改的名字为.txt的文件</span>



<span class="c1">#-exec结合多个命令</span>
<span class="c1">#我们无法在-exec参数中直接使用多个命令，不过我们可以把多个命令写到一个shellscript中，然后执行</span>
-exec ./test.sh <span class="o">{}</span> <span class="se">\;</span>
find . -type f -name <span class="s2">&#34;*.sh&#34;</span> -mmin -10 -exec sh <span class="o">{}</span> <span class="se">\;</span>



<span class="c1">#让find跳过特定目录</span>
-prune



<span class="c1">#利用find搭配tar打包</span>
<span class="c1">#查找7天内的文件并打包</span>
<span class="c1">#建议使用绝对路径，管道无效，所有要定向到文件</span>
find /dir/path/zhang -type -f -mmtime -7 &gt; /dir/path/zhang/zhang.list <span class="o">&amp;&amp;</span> tar -T /dir/path/zhang/zhang.list -czvf /dir/path/zhang123.tar.gz
<span class="c1">#检查是否正确</span>
tar -tf /dir/path/zhang123.tar.gz

<span class="c1">#不能使用find -exec tar，这样打包以后只有最后一个文件</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h3 id="利用stat命令查看atime-mtime-ctime">利用<code>stat</code>命令查看atime, mtime, ctime</h3>
<p><code>stat</code> - display file or file system status</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">stat 1.txt

#Access:
#Modify:
#Change:
</code></pre></td></tr></table>
</div>
</div><br>
<h3 id="利用touch命令修改atime-mtime-ctime">利用<code>touch</code>命令修改atime, mtime, ctime</h3>
<p>touch - change file timestamps</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#-a     change only the access time
#-m     change only the modification time
#-d     instead of current time
#-t     instead of current time
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="玩转xargs">玩转<code>xargs</code></h2>
<p>xargs - build and execute command lines from standard input</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#xargs能够处理stdin并将其转换为特定命令的命令行参数</span>
<span class="c1">#也可以将单行或多行输入文本转换成其他格式(如多行变单行)</span>
cmd <span class="p">|</span> xargs


<span class="c1">#将多行输入转换为单行输出</span>
<span class="nb">echo</span> -e <span class="s2">&#34;1\n2\n3&#34;</span> <span class="p">|</span> xargs	<span class="c1">#将换行符替换为空格</span>
<span class="c1">#将单行输入转换成多行输出</span>
<span class="nb">echo</span> <span class="s2">&#34;1 2 3&#34;</span> <span class="p">|</span> xargs -n 1	<span class="c1">#每行一个参数</span>
<span class="nb">echo</span> <span class="s2">&#34;hahaZhahaZhahaZhaha&#34;</span> <span class="p">|</span> xargs -n <span class="m">2</span> -d Z	<span class="c1">#-d指定分隔符</span>


<span class="c1">#读取stdin，将格式化参数传递给命令</span>
cat test.txt <span class="p">|</span> xargs -n <span class="m">1</span> ./zhang.sh	<span class="c1">#zhang.sh arg1; zhang.sh arg2... 每次提供一个参数</span>
cat test.txt <span class="p">|</span> xargs -n X ./zhang.sh	<span class="c1">#X为参数个数，一次提供全部参数</span>


<span class="c1">#指定替换字符串</span>
cat test.txt <span class="p">|</span> xargs -I <span class="o">{}</span> ./zhang.sh <span class="o">{}</span>


<span class="c1">#结合find使用xargs</span>
find . -type f -name <span class="s2">&#34;*.txt&#34;</span> -print0 <span class="p">|</span> xargs -0 ls	<span class="c1">#-print0无换行输出, -0将\0作为输入界定符</span>


<span class="c1">#统计某文件行数</span>
find /path -type f -name <span class="s2">&#34;*.c&#34;</span> -print0 <span class="p">|</span> xargs -0 wc -l


<span class="c1">#结合stdin，运用while和子shell</span>
cat file.txt <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> arg<span class="p">;</span> <span class="k">do</span> cat <span class="nv">$arg</span><span class="p">;</span> <span class="k">done</span> <span class="o">==</span> cat file.txt <span class="p">|</span> xargs - <span class="o">{}</span> cat <span class="o">{}</span>
cmd0 <span class="p">|</span> <span class="o">(</span>cmd1<span class="p">;</span> cmd2<span class="p">;</span> cmd3<span class="o">)</span> <span class="p">|</span> cmd4	<span class="c1">#子shell</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="用tr进行转换">用<code>tr</code>进行转换</h2>
<p>tr - translate or delete characters</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#tr命令经常用来编写优美的单行命令</span>
<span class="c1">#tr可对来自stdin的字符 进行替换、删除以及压缩</span>


<span class="nb">echo</span> <span class="s2">&#34;AH WONDERFUL&#34;</span> <span class="p">|</span> tr <span class="s1">&#39;A-Z&#39;</span> <span class="s1">&#39;a-z&#39;</span>	<span class="c1">#转换大小写</span>
<span class="nb">echo</span> <span class="s2">&#34;AH WONDERFUL&#34;</span> <span class="p">|</span> tr <span class="s1">&#39;A-Z&#39;</span> <span class="s1">&#39;a-b&#39;</span> --&gt; ab bbbbbbbbb
<span class="c1">#tr [option] set1 set2</span>
<span class="c1">#如果两个字符集长度不相等，那么set2会不断重复其最后一个字符，直到长度与set1相同</span>


<span class="nb">echo</span> <span class="m">12345</span> <span class="p">|</span> tr <span class="s1">&#39;0-9&#39;</span> <span class="s1">&#39;9876543210&#39;</span>	<span class="c1">#数字加密</span>
<span class="nb">echo</span> <span class="m">87654</span> <span class="p">|</span> tr <span class="s1">&#39;9876543210&#39;</span> <span class="s1">&#39;0-9&#39;</span>	<span class="c1">#数字解密</span>


<span class="nb">echo</span> <span class="s1">&#39;He is a cool boy, and she is a beautiful girl&#39;</span> <span class="p">|</span> tr <span class="s1">&#39;A-Za-z&#39;</span> <span class="s1">&#39;NOPQRSRUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&#39;</span>	<span class="c1">#加密</span>
<span class="nb">echo</span> <span class="s1">&#39;Ur vf n pbby obl, naq fur&#39;</span> <span class="p">|</span> tr <span class="s1">&#39;NOPQRSRUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&#39;</span> <span class="s1">&#39;A-Za-z&#39;</span>	<span class="c1">#解密</span>

cat 1.txt <span class="p">|</span> tr <span class="s1">&#39;\t&#39;</span> <span class="s1">&#39; &#39;</span>	<span class="c1">#将制表符转换为空格</span>


<span class="c1">#删除字符</span>
<span class="nb">echo</span> <span class="s2">&#34;Hello 530 World&#34;</span> <span class="p">|</span> tr -d <span class="s1">&#39;0-9&#39;</span>	<span class="c1">#-d删除，删除数字</span>
Hello  World
<span class="nb">echo</span> <span class="s2">&#34;Hello 520 World&#34;</span> <span class="p">|</span> tr -d -c <span class="s1">&#39;0-9&#39;</span>	<span class="c1">#-c补集</span>
 <span class="m">520</span>


<span class="c1">#压缩字符，将连续的重复字符压缩为单个字符</span>
<span class="nb">echo</span> <span class="s2">&#34;GNU&#39;s    not   Unix&#34;</span> <span class="p">|</span> tr -s <span class="s1">&#39; &#39;</span>	<span class="c1">#-s压缩，压缩空格</span>
GNU<span class="s1">&#39;s not Unix
</span><span class="s1">
</span><span class="s1">
</span><span class="s1">echo -e &#34;1\n2\n3\n4\n5&#34; &gt; sum.txt
</span><span class="s1">cat sum.txt | echo $[ $(tr &#39;</span><span class="se">\n</span><span class="s1">&#39; &#39;</span>+<span class="err">&#39;</span><span class="o">)</span> <span class="m">0</span> <span class="o">]</span> -- <span class="nb">echo</span> $<span class="o">[</span>1+2+3+4+5+0<span class="o">]</span>


<span class="c1">#tr字符类</span>
<span class="se">\a</span>	终端鸣响
<span class="se">\b</span>	退格
<span class="se">\f</span>	换页
<span class="se">\n</span>	换行
<span class="se">\r</span>	回车
<span class="se">\t</span>	水平制表符
<span class="se">\v</span>	垂直制表符
string1-stringN	<span class="c1">#从字符1到字符N升序过程中的所有字符</span>
<span class="o">[</span>字符*次数<span class="o">]</span>
<span class="o">[</span>:alnum:<span class="o">]</span>	<span class="c1">#所有字母和数字</span>
<span class="o">[</span>:alpha:<span class="o">]</span>	<span class="c1">#所有字母</span>
<span class="o">[</span>:digit:<span class="o">]</span>	<span class="c1">#所有数字</span>
<span class="o">[</span>:lower:<span class="o">]</span>	<span class="c1">#所有小写字母</span>
<span class="o">[</span>:upper:<span class="o">]</span>	<span class="c1">#所有大写字母</span>
<span class="o">[</span>:graph:<span class="o">]</span>	<span class="c1">#所有可打印字符，不含空格</span>
<span class="o">[</span>:print:<span class="o">]</span>	<span class="c1">#所有可打印字符，包含空格</span>
<span class="o">[</span>:blank:<span class="o">]</span>	<span class="c1">#所有水平排列的空白字符</span>
<span class="o">[</span>:cntrl:<span class="o">]</span>	<span class="c1">#所有控制字符</span>
<span class="o">[</span>:punct:<span class="o">]</span>	<span class="c1">#所有标点字符</span>
<span class="o">[</span>:space:<span class="o">]</span>	<span class="c1">#所有空白字符</span>
<span class="o">[</span>:xdigit:<span class="o">]</span>	<span class="c1">#所有十六进制数</span>
<span class="o">[=</span>字符<span class="o">]</span>	<span class="c1">#指定字符</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="校验和-与-核实文件完整性md5sum">校验和 与 核实文件完整性(<code>md5sum</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#校验和(checksum)程序从文件中生成校验和密钥，然后利用校验和密钥核实文件的完整性</span>
<span class="c1">#校验和对于编写备份脚本或系统维护脚本非常重要，因为它们都会涉及通过网络传输文件</span>
<span class="c1">#通过使用校验和核实，我们就可以识别那些在网络传输过程中出现损坏的文件，并重传，从而确保数据完整性</span>
<span class="c1">#校验和对于核实数据完整性非常有用</span>
<span class="c1">#广泛使用的校验和技术有：md5sum, sha1sum</span>


<span class="c1">#对单个文件进行校验</span>
md5sum sum.txt &gt; sum.md5
<span class="c1">#302c28003d487124d97c242de94da856  sum.txt</span>
md5sum -c sum.md5	<span class="c1">#-c检查</span>
<span class="c1">#sum.txt: 确定</span>


<span class="c1">#对目录进行校验</span>
<span class="c1">#对目录计算校验和意味着我们需要对目录中的所有文件以递归的方式进行计算</span>
yum install -y md5deep
md5deep -r ./dir &gt; dir.md5	<span class="c1">#recursive递归</span>
md5sum -c dir.md5


<span class="c1">#可以将测试dir下某个文件更改一下，校验的时候会报错</span>
</code></pre></td></tr></table>
</div>
</div><br>
## 排序、单一、重复(`sort`,`uniq`)
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#sort - 对文本文件进行行排序</span>
<span class="c1">#uniq - 删除排序文件中的重复行</span>


<span class="nb">echo</span> -e <span class="s2">&#34;333\n1&#34;</span> &gt; 1.txt<span class="p">;</span> <span class="nb">echo</span> -e <span class="s2">&#34;22\n22&#34;</span> &gt; 2.txt
sort 1.txt 2.txt -o ./sorted.txt
<span class="c1">#1</span>
<span class="c1">#22</span>
<span class="c1">#22</span>
<span class="c1">#333</span>
cat sortec.txt <span class="p">|</span> uniq
<span class="c1">#1</span>
<span class="c1">#22</span>
<span class="c1">#333</span>


sort -n	<span class="c1">#按数字进行排序</span>
sort -r	<span class="c1">#逆向排序</span>
sort -M	<span class="c1">#按月份排序</span>
sort -C	<span class="c1">#检查是否排序</span>
sort -b	<span class="c1">#忽略空白</span>


<span class="c1">#依据键或列进行排序</span>
sort -k <span class="m">2</span> data.txt	<span class="c1">#依据第二列来排序</span>


<span class="c1">#uniq要么使用管道，要么使用排过序的文件作文输入</span>
uniq -u sorted.txt	<span class="c1">#只显示唯一的行(即没有重复出现的行)</span>
uniq -d sorted.txt	<span class="c1">#只显示重复的行</span>
uniq -s <span class="m">2</span> -w <span class="m">2</span> sorted.txt	<span class="c1">#-s忽略前2个字符，-w指定用于比较的最大字符数</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="临时文件命名随机数">临时文件命名、随机数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#在编写shell脚本时，我们经常需要存储临时文件。最适合存储临时数据的位置是 /tmp</span>
<span class="c1">#/tmp目录中的内容会在系统重启后被清空</span>

<span class="nv">filename</span><span class="o">=</span><span class="nv">$RANDOM</span>	<span class="c1">#RANDOM返回一个随机数</span>
<span class="nv">filename2</span><span class="o">=</span><span class="nv">$$</span>	<span class="c1">#当前shell的PID</span>
<span class="nv">filename3</span><span class="o">=</span><span class="k">$((</span>date <span class="o">+%</span>F<span class="k">))</span>	<span class="c1">#通过日期命令</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="split命令分割文件">split命令分割文件</h2>
<p>使用<code>split</code>命令来分割一个大文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#某些情况下，需要把文件分割成多个更小的片段</span>
dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">bs</span><span class="o">=</span>100k <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">of</span><span class="o">=</span>./data.file	<span class="c1">#生成一个大小100k内容全是0的文件</span>
split -b 20k data.file	<span class="c1">#-d指定分割大小</span>
<span class="c1">#data.file xaa xab xac xad xae,这五个文件都为20k</span>
<span class="c1">#我测试了一下，几个文件加起来数据没变，几个文件总行数没变</span>
<span class="c1">#单位有 k, m, G, c(byte), w(word)</span>
<span class="c1">#-d以数字为后缀， -a指定后缀长度</span>


split data.file -b 20k -d -a <span class="m">2</span> spt	<span class="c1">#增加前缀名&#39;spt&#39;</span>
<span class="c1">#data.file  spt00  spt01  spt02  spt03  spt04</span>


split -l <span class="m">10</span> data.file	<span class="c1">#-l按行数来分割文件</span>
<span class="c1">#split只能根据大小或行数分割文件</span>


<span class="c1">#csplit可以根据文件本身特点进行分割</span>
-f	<span class="c1">#指定分割后文件前缀</span>
-n	<span class="c1">#指定分割后文件后缀数字个数</span>
-b	<span class="c1">#指定后缀格式</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="根据扩展名切分文件名">根据扩展名切分文件名</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#借助%操作符将名称从 “名称.扩展名” 格式中提取出来</span>


<span class="nv">file</span><span class="o">=</span><span class="s2">&#34;zhang.txt&#34;</span>
<span class="nv">name1</span><span class="o">=</span><span class="si">${</span><span class="nv">file</span><span class="p">%.*</span><span class="si">}</span>	<span class="c1">#删除位于%右侧的通配符(.*)所匹配的字符串，通配符从右向左进行匹配</span>
<span class="c1">#zhang</span>
<span class="c1">#*号通配符，.号</span>
<span class="c1">#%属于非贪婪匹配(non-greedy),它会匹配通配符最短结果</span>
<span class="c1">#%%属于贪婪匹配(greedy)，它会匹配符号条件的最长字符串</span>



<span class="nv">name2</span><span class="o">=</span><span class="si">${</span><span class="nv">file</span><span class="p">#*.</span><span class="si">}</span>	<span class="c1">#删除位于#右侧的通配符(*.)所匹配的字符串，通配符从左向右进行匹配</span>
<span class="c1">#txt</span>
<span class="c1"># #属于非贪婪匹配</span>
<span class="c1"># ##属于贪婪匹配</span>


<span class="c1">#栗子</span>
<span class="nv">URL</span><span class="o">=</span>“www.google.com”
<span class="nb">echo</span> <span class="si">${</span><span class="nv">URL</span><span class="p">%.*</span><span class="si">}</span>	<span class="c1">#非贪婪匹配，移除最右边.及其后面内容</span>
www.google
<span class="nb">echo</span> <span class="si">${</span><span class="nv">URL</span><span class="p">%%.*</span><span class="si">}</span>	<span class="c1">#贪婪匹配</span>
www
<span class="nb">echo</span> <span class="si">${</span><span class="nv">URL</span><span class="p">#*.</span><span class="si">}</span>	<span class="c1">#非贪婪匹配，移除最左边.及其前面内容</span>
google.com
<span class="nb">echo</span> <span class="si">${</span><span class="nv">URL</span><span class="p">##*.</span><span class="si">}</span>	<span class="c1">#贪婪匹配</span>
com
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="批量重命名和移动">批量重命名和移动</h2>
<p>综合运用<code>find</code>、<code>rename</code>、<code>mv</code>命令。</p>
<br>
<h2 id="拼写检查与词典操作">拼写检查与词典操作</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#Linux大多数发行版都含有一份词典文件，另外还有一个被称为aspell的拼写检查命令</span>
<span class="c1">#words --&gt; /usr/share/dict/linux.words</span>

grep <span class="s2">&#34;^good&#34;</span> /usr/share/dict/linux.words

aspell
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="交互输入自动化">交互输入自动化</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#写一个读取交互式输入脚本</span>
vi jiaohu.sh

<span class="c1">#!/bin/bash</span>
<span class="nb">read</span> -p <span class="s2">&#34;Input a number:&#34;</span> num
<span class="nb">read</span> -p <span class="s2">&#34;Input name:&#34;</span> name
<span class="nb">echo</span> <span class="s2">&#34;You have enterd number:</span><span class="nv">$num</span><span class="s2">, name:</span><span class="nv">$name</span><span class="s2">&#34;</span>

<span class="nb">echo</span> -e <span class="s2">&#34;1\nzhang&#34;</span> <span class="p">|</span> ./jiaohu.sh
You have entered number:1, name:hello


<span class="c1">#or</span>
<span class="nb">echo</span> -e <span class="s2">&#34;1\nzhang&#34;</span> &gt; input.txt
./jiaohu.sh &lt; input.txt


<span class="c1">#交互式输入自动化</span>
<span class="c1">#用expect实现自动化</span>
yum install -y expect
vim auto_expect.sh


<span class="c1">#!/bin/expect</span>
spawn ./jiaohu.sh	<span class="c1">#spawn指定需要自动化哪一个命令</span>
expect <span class="s2">&#34;Input a number:&#34;</span>	<span class="c1">#expect提供需要等待的消息</span>
send <span class="s2">&#34;1\n&#34;</span>		<span class="c1">#send是要发送的消息</span>
expect <span class="s2">&#34;Input name:&#34;</span>
send <span class="s2">&#34;zhang&#34;</span>
expect eof	<span class="c1">#expect eof指明命令交互结束</span>

./auto_expect.sh
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h1 id="以文件之名">以文件之名</h1>
<h2 id="简介-3">简介</h2>
<p>Unix将操作系统中的一切都视为文件。</p>
<br>
<h2 id="生成任意大小的文件dd">生成任意大小的文件(<code>dd</code>)</h2>
<p>由于各种原因，可能需要生成一个包含随机数据的文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#dd命令会克隆给定的输入内容，然后将一模一样的副本写到输出</span>
<span class="c1">#如果不指定if，dd会从stdin中读取输入；如果不指定of，dd会输出到stdout</span>
<span class="c1">#/dev/zero是一个字符设备，它会不断返回0值字节(\0)</span>

dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>junk.data <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span><span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="文本文件的交集与差集">文本文件的交集与差集</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#comm命令用于两个文件之间的比较</span>
<span class="c1">#交集(intersection),差集(set difference), 求差</span>
<span class="c1">#comm必须使用排过序的文件作为输入</span>


<span class="nb">echo</span> -e <span class="s2">&#34;1\n2\n3&#34;</span> &gt; A.txt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> -e <span class="s2">&#34;3\n2\n3&#34;</span> &gt; B.txt
sort -n A.txt -o A.txt <span class="o">&amp;&amp;</span> sort -n B.txt -o B.txt
comm A.txt B.txt
<span class="c1">#输出第一列为A独有，第二列为B独有，第三列为交集</span>


comm A.txt B.txt -1 -2
<span class="c1">#-1从输出中删除第一列，-2删除第二列，-3删除第三列</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="查找并删除重复文件">查找并删除重复文件</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#重复文件指的是那些虽然名字不同但内容却一模一样的文件</span>

ls -lS	<span class="c1">#以文件大小排序，识别大小相等的文件</span>
md5sum	<span class="c1">#接下来计算这些文件的校验和</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="创建长路径目录">创建长路径目录</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">mkdir -p /home/zhang/1/22/333 2&gt;/dev/null
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="文件权限所有权和粘滞位">文件权限、所有权和粘滞位</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#用户(user)，用户组(group)，其他用户(other)</span>

ll ./*
<span class="c1">#d目录，c字符设备，b块设备，l符号链接，s套接字，p管道，-普通文件</span>


<span class="c1">#用户还有一个称为setuid(S)的特殊权限，它出现在用户的x位置</span>
<span class="c1">#setuid权限允许用户以其拥有者的权限来执行可执行文件，即便这个文件是由其他用户运行的</span>
-rwSrw-r--



<span class="c1">#组也拥有一个setgid(S)权限，它出现在组的x位置</span>
<span class="c1">#它允许以同该目录拥有者所在组相同的有效组权限来运行可执行文件</span>
-rwxrwSr--



<span class="c1">#目录有一个特殊权限，叫做粘滞位(sticky bit)(T或t)，出现在其他用户的x位置</span>
<span class="c1">#当一个目录设置了粘滞位，只有创建该目录的用户才能删除目录中的文件,即便group和other有w权限</span>
-rwxr--rwT



chmod <span class="nv">u</span><span class="o">=</span>rwx <span class="nv">g</span><span class="o">=</span>rw <span class="nv">o</span><span class="o">=</span>r file1
chmod u+x g-w file2
chmod <span class="m">744</span> file3


chmod a+x . -R	<span class="c1">#以递归方式设置权限</span>
chown user.group . -R	<span class="c1">#以递归方式设置所有权</span>


chmod a+t dir1	<span class="c1">#设置粘滞位</span>


chmod +s fiel4
chown root.root file4
chmod +s file4
./file4	<span class="c1">#每次file4都是以root运行</span>

<span class="c1">#setuid的使用不是无限制的，它只能应用在Linux ELF格式二进制，而不能用于脚本文件。</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="创建不可修改文件">创建不可修改文件</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#不可修改(immutable),是保护文件不被修改的安全手段之一。</span>
<span class="c1">#一旦文件被设置为不可修改，任何用户(包括root)都不能修改，除非将其不可修改属性移除</span>

chattr	<span class="c1">#修改文件在Linux第二扩展文件系统(E2fs)上的特有属性</span>
chattr +i file1	<span class="c1">#这样就无法删除file1</span>
chattr -i file1
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="批量生成空白文件">批量生成空白文件</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#touch命令可用来生成空白文件，如果文件存在，则可以用它修改文件的时间戳</span>

<span class="k">for</span> name in <span class="o">{</span>1..100<span class="o">}</span>.txt<span class="p">;</span><span class="k">do</span>
touch <span class="nv">$name</span>
<span class="k">done</span>


touch -a/-m	<span class="c1">#更改文件访问/修改时间</span>
touch -d <span class="s2">&#34;Thu Oct 31 14:20:13 CST 2017&#34;</span> file1	<span class="c1">#指定特定时间戳</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="查找符号链接及其指向目标">查找符号链接及其指向目标</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#符号链接(软链接)只不过是指向其他文件的指针</span>

ln -s /usr/bin /bin
ls -l / <span class="p">|</span> grep <span class="s2">&#34;^l&#34;</span>
find / -maxdepth <span class="m">1</span> -type l

readlink /bin	<span class="c1">#找出链接目标</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="列举文件类型统计信息">列举文件类型统计信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#在Unix/Linux系统中，文件类型并不是由文件扩展名决定的</span>

file /etc/passwd
file -b /etc/passwd
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="环回文件与挂载mount">环回文件与挂载(<code>mount</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#环回文件系统是指那些在文件中而非物理设备中创建的文件系统</span>

dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>loopback.file <span class="nv">bs</span><span class="o">=</span>1G <span class="nv">count</span><span class="o">=</span><span class="m">1</span>
mkfs.ext4 loopback.file
mount -o loop loopback.file /mnt/loopback	<span class="c1">#-o loop来挂载环回文件</span>
df -h
umount /mnt/loopback


<span class="c1">#将ISO文件作为环回文件挂载</span>
mount -o loop linux.iso /mnt/iso
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="生成iso文件以及混合iso">生成ISO文件以及混合ISO</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#可引导光盘自身具备引导能力，也可以运行操作系统或其他软件。不可引导光盘则做不到这些。</span>

cat /dev/cdrom  &gt; /dev/sdc	<span class="c1">#sdc指U盘</span>
dd <span class="k">if</span><span class="o">=</span>/dev/cdrom <span class="nv">of</span><span class="o">=</span>/dev/sdc	<span class="c1">#将ISO写入usb存储设备</span>
mkisofs -V <span class="s2">&#34;Label&#34;</span> -o /dev/sdc /dev/cdrom


cdrecord -v <span class="nv">dev</span><span class="o">=</span>/dev/cdrom image.iso
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="查找文件差异并进行修补">查找文件差异并进行修补</h2>
<p>diff - compare files line by line</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#补丁文件(patch file)</span>
<span class="c1">#diff命令可以生成差异文件</span>

diff -u file1 file2	<span class="c1">#一体化形式输出</span>
diff -u file1 file2 &gt; diff.patch
patch -p1 file1 &lt; diff.patch	<span class="c1">#得到file2</span>
patch -p1 file2 &lt; diff.patch	<span class="c1">#得到file1</span>
patch -R file1 &lt; diff.patch<span class="p">;</span> patch -R file2 &lt; diff.patch	<span class="c1">#还原</span>


<span class="c1">#diff也能够以递归的形式作用于目录，它对目录中所有内容生成差异输出</span>
diff -Naur dir1 dir2
<span class="c1">#-N将所有确实文件视为空文件， -a将所有文件视为文本文件</span>
<span class="c1">#-u生成一体化输出， -r遍历目录下所有文件</span>
</code></pre></td></tr></table>
</div>
</div><p>栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">echo</span> -e <span class="s1">&#39;1\n1\n1\n1&#39;</span> &gt; /tmp/1.txt
<span class="nb">echo</span> -e <span class="s1">&#39;1\n1\n0\n1&#39;</span> &gt; /tmp/2.txt


<span class="c1">#比较</span>
diff -u 1.txt 2.txt
--- 1.txt       2018-12-14 16:08:36.457495835 +0800
+++ 2.txt       2018-12-14 16:08:37.574495820 +0800
@@ -1,4 +1,4 @@
 <span class="m">1</span>
 <span class="m">1</span>
-1
+0
 <span class="m">1</span>


<span class="c1">#解释</span>
--- 1.txt       2018-12-14 16:08:36.457495835 +0800
+++ 2.txt       2018-12-14 16:08:37.574495820 +0800
<span class="c1">#第一部分，是文件的基本信息</span>
<span class="c1">#---表示变动前的文件</span>
<span class="c1">#+++表示变动后的文件</span>


@@ -1,4 +1,4 @@
<span class="c1">#第二部分，变动的位置用两个@作为起首和结束。</span>
<span class="c1">#-号表示第一个文件(1.txt), 1表示第一行，4表示连续四行。也就是第一个文件从第一行开始连续四行</span>
<span class="c1">#+号表示第二个文件(2.txt), 1表示第一行，4表示连续四行。</span>


 <span class="m">1</span>
 <span class="m">1</span>
-1
+0
 <span class="m">1</span>
<span class="c1">#第三部分表示变动的具体内容</span>
<span class="c1">#除了有变动的那些行以外，也是上下文各显示3行。它将两个文件的上下文合并显示在一起，所以称为合并显示</span>
<span class="c1">#每一行最前面的标志位，空表示无变动，减号表示第一个文件删除的行，加号表示第二个文件新增的行</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="head与tail"><code>head</code>与<code>tail</code></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">head file1<span class="p">;</span> tail file1	<span class="c1">#head与tail默认打印10行</span>
head -n <span class="m">5</span> file1<span class="p">;</span> tail -n <span class="m">6</span> file1	<span class="c1">#指定行数</span>
head -n -5 file1	<span class="c1">#打印除了最后5行外所有行</span>
tail -n +<span class="o">(</span>5+1<span class="o">)</span> file1	<span class="c1">#打印除了开始5行外所有行</span>

tail -f /var/log/nginx/access.log	<span class="c1">#--follow，动态关注文件</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="只列出目录的其他方法">只列出目录的其他方法</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ls -d .
ls -l . | grep &#34;^d&#34;
ls -F . | grep &#34;/$&#34;
find . -maxdepth 1 -type d
</code></pre></td></tr></table>
</div>
</div><br/>
## pushd和popd
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#在命令行中使用pushd和popd快速定位，pushd和popd以栈的方式运作</span>
<span class="c1">#当没有鼠标时，复制粘贴就不怎么实用了</span>
<span class="c1">#pushd和popd可以用于在多个目录之间进行切换而无需复制并粘贴目录路径</span>

<span class="nb">pushd</span> /home/user1<span class="p">;</span> <span class="nb">pushd</span> /home/user2<span class="p">;</span> <span class="nb">pushd</span> /home/user3	<span class="c1">#将路径添加到栈</span>
<span class="nb">pushd</span> +2	<span class="c1">#切换到/home/user3</span>

<span class="nb">popd</span>	<span class="c1">#移除最近添加入栈的目录</span>


<span class="nb">cd</span> /root<span class="p">;</span> <span class="nb">cd</span> /home/user
<span class="nb">cd</span> -	<span class="c1">#回到上次的目录</span>
<span class="nb">cd</span> ..	<span class="c1">#切换到上一级目录</span>
<span class="nb">cd</span> ~	<span class="c1">#切换到用户主目录</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="统计文件的行数单词数字符数">统计文件的行数、单词数、字符数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#wc(word count)，是一个统计工具</span>

wc -l file1	<span class="c1">#统计行数</span>
wc -w file1	<span class="c1">#统计单词数</span>
wc -c file	<span class="c1">#统计字符数</span>
wc -L file	<span class="c1">#打印最长行长度</span>
wc file1	<span class="c1">#行、单词、字符数</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="目录树">目录树</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#tree命令是以图形化的树状结构打印文件和目录,在Linux发行版中默认未安装</span>

yum install -y tree
tree /home/zhang
tree /home/zhang -P <span class="s2">&#34;*.sh&#34;</span>	<span class="c1">#只标记出.sh文件</span>
tree /home/zhang -I <span class="s2">&#34;*.sh&#34;</span>	<span class="c1">#标记出除.sh文件外所有文件</span>
tree /home/zhang -h	<span class="c1">#显示大小</span>

tree /home/zhang -H http://localhost -o tree.html	<span class="c1">#以html形式输出目录树</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h1 id="让文本飞">让文本飞</h1>
<h2 id="简介-4">简介</h2>
<p>shell脚本可以将<code>sed</code>, <code>awk</code>, <code>grep</code>, <code>cut</code>等这类优美的工具组合在一起，用于解决文本处理相关问题。</p>
<br>
<h2 id="正则表达式">正则表达式</h2>
<p>Regular Expression</p>
<p>正则表达式是一种用于文本匹配的形式小巧、具有高度针对性的编程语言。只依靠通配符技术，能够匹配的文本范围相当有限。</p>
<br>
<p><strong>正则表达式基本组成</strong></p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>行起始标记</td>
</tr>
<tr>
<td>$</td>
<td>行尾标记</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>匹配包含在[]中的任意一个字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配出[^]之外任意一个字符</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配[]中范围内的任意一个字符</td>
</tr>
<tr>
<td>？</td>
<td>重复0或1次</td>
</tr>
<tr>
<td>+</td>
<td>重复&gt;=1次</td>
</tr>
<tr>
<td>*</td>
<td>重复&gt;=0次</td>
</tr>
<tr>
<td>()</td>
<td>创建一个用于匹配的子串</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n, }</td>
<td>重复&gt;=n次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>竖线l</td>
<td>匹配竖线l两边任意一项</td>
</tr>
</tbody>
</table>
<br>
<p><strong>POSIX字符类</strong></p>
<p>POSIX字符类(POSIX character class),是一个形如[:&hellip;:]的特殊元序列，它用于匹配特定的字符范围。<br></p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>字母与数字字符</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>字母字符</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格与制表符</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>数字字符</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>大写字母</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
</tr>
<tr>
<td>[:space:]</td>
<td>所有空白字符</td>
</tr>
</tbody>
</table>
<br>
<p><strong>元字符</strong></p>
<p>元字符(meta character)，是一种Perl风格的正则表达式，只有一部分文本处理工具支持它。</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\A</td>
<td>字符串的开头</td>
</tr>
<tr>
<td>\b</td>
<td>单词边界</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界</td>
</tr>
<tr>
<td>\d</td>
<td>单个数字字符</td>
</tr>
<tr>
<td>\D</td>
<td>单个非数字字符</td>
</tr>
<tr>
<td>\f</td>
<td>换页字符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\s</td>
<td>单个空白字符</td>
</tr>
<tr>
<td>\S</td>
<td>单个非空白字符</td>
</tr>
<tr>
<td>\t</td>
<td>跳进字符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直跳进字符</td>
</tr>
<tr>
<td>\w</td>
<td>单个单词字符(数字，字母和_)</td>
</tr>
<tr>
<td>\W</td>
<td>单个非单词字符</td>
</tr>
<tr>
<td>\z</td>
<td>字符串的结尾</td>
</tr>
<tr>
<td>\Z</td>
<td>匹配字符串的结尾，或结尾的换行符之前</td>
</tr>
</tbody>
</table>
<br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-re" data-lang="re"><span class="ow">#</span><span class="n">匹配一个ipv4地址</span>
<span class="ow">[</span><span class="n">0</span><span class="ow">-</span><span class="n">9</span><span class="ow">]{</span><span class="n">1</span><span class="ow">,</span><span class="n">3</span><span class="ow">}</span><span class="err">\</span><span class="ow">.[</span><span class="n">0</span><span class="ow">-</span><span class="n">9</span><span class="ow">]{</span><span class="n">1</span><span class="ow">,</span><span class="n">3</span><span class="ow">}</span><span class="err">\</span><span class="ow">.[</span><span class="n">0</span><span class="ow">-</span><span class="n">9</span><span class="ow">]{</span><span class="n">1</span><span class="ow">,</span><span class="n">3</span><span class="ow">}</span><span class="err">\</span><span class="ow">.[</span><span class="n">0</span><span class="ow">-</span><span class="n">9</span><span class="ow">]{</span><span class="n">1</span><span class="ow">,</span><span class="n">3</span><span class="ow">}</span>


<span class="ow">#</span><span class="n">匹配一个邮箱地址</span>
<span class="ow">[</span><span class="err">\</span><span class="n">w</span><span class="ow">]+</span><span class="o">@</span><span class="ow">[</span><span class="err">\</span><span class="n">w</span><span class="ow">]</span><span class="err">\</span><span class="ow">.</span><span class="n">com</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="用grep在文件中搜索文本">用grep在文件中搜索文本</h2>
<p><code>grep</code>命令是Unix中用于文本搜索的工具，它能够接受正则表达式和通配符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">grep <span class="s2">&#34;匹配文本/通配符&#34;</span> file1 file2... --color<span class="o">=</span>auto	<span class="c1">#重点标记匹配</span>
grep -E <span class="s2">&#34;正则表达式&#34;</span> file
egrep <span class="s2">&#34;正则&#34;</span> file


grep -v	<span class="c1">#反向匹配</span>
grep -c	<span class="c1">#统计匹配行数</span>
grep -n	<span class="c1">#打印出匹配的行号</span>
grep -o	<span class="c1">#唯一匹配</span>
grep -l	<span class="s2">&#34;匹配&#34;</span> file1 file2	<span class="c1">#返回匹配的文件名</span>
grep -R	<span class="c1">#递归匹配</span>
grep -i	<span class="c1">#忽略大小写</span>
grep -e <span class="s2">&#34;匹配1&#34;</span> -e <span class="s2">&#34;匹配2&#34;</span>	<span class="c1">#匹配多个样式</span>
grep -f match.txt file1	<span class="c1">#从match.txt文件读取匹配</span>
grep <span class="s2">&#34;匹配&#34;</span> --include<span class="o">=</span>*.<span class="o">{</span>sh,txt<span class="o">}</span> --exclude<span class="o">=</span>*.log --exclude-dir<span class="o">=</span>/home/user -r /home	<span class="c1">#包括或排除文件</span>
-A/-B n	<span class="c1">#输出匹配 之后/之前 n行</span>
-c n	<span class="c1">#输出匹配 前后 n行</span>



<span class="c1">#正则匹配多个</span>
egerep <span class="s2">&#34;(a|b)&#34;</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="用cut按列切分文件">用cut按列切分文件</h2>
<p><code>cut</code>是一个将文本按列进行切分的小工具，它也可以指定每列定界符。在cut的术语中，每列都是一个字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#制表符&#39;\t&#39; 是cut默认的定界符</span>
cut -d<span class="s1">&#39; &#39;</span> -f1 1.txt	<span class="c1">#-d指定分隔符，-f打印第几个字段</span>
cut -f1,2,3	<span class="c1">#打印1,2，3列</span>
-c字符；	-b字节；
cut -c 1-5 1.txt	<span class="c1">#打印1-5字符</span>
cut -c -2 1.txt	<span class="c1">#打印前2个字符</span>
cut -c 3-	<span class="c1">#打印第3个字符到行尾</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="统计特定文件词频">统计特定文件词频</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#单词解析可以用 关联数组,正则表达式配合sed,awk,grep等工具来完成</span>
<span class="c1">#关联数组中，将单词作为数组索引，单词次数作为数组值</span>

egrep -o <span class="s2">&#34;\b[:alpha:]+\b&#34;</span>	<span class="c1">#匹配单词</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="sed入门">sed入门</h2>
<p><code>sed</code>是stream editor(流编辑器)的缩写，它是文本处理中非常重要的工具。能够完美地配合正则表达式使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#sed - stream editor for filtering and transforming text</span>
<span class="c1">#字符/在sed中最为定界符使用</span>


<span class="c1">#替换</span>
<span class="c1">#sed &#39;s/匹配样式/替代字符串/&#39;</span>
sed <span class="s1">&#39;s/pattern/repalce/&#39;</span> file	<span class="c1">#替换</span>
sed -i <span class="s1">&#39;s/pattern/repalce/&#39;</span> file	<span class="c1">#将替换应用于file</span>


<span class="nb">echo</span> <span class="s2">&#34;1.txt&#34;</span> &gt; 1.txt <span class="o">&amp;&amp;</span> sed <span class="s1">&#39;s/txt/haha&#39;</span> 1.txt	<span class="c1">#在输出中用haha替换txt</span>
sed -i <span class="s1">&#39;s/txt/haha/&#39;</span> 1.txt	<span class="c1">#将1.txt文件中的txt用haha替换掉</span>
<span class="c1">#-i选项替换原文件</span>


<span class="nb">echo</span> <span class="s2">&#34;hahaha&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/ha/HA/g&#39;</span>	<span class="c1">#全部替换</span>
<span class="nb">echo</span> <span class="s2">&#34;hahaha&#34;</span>	<span class="p">|</span> sed <span class="s1">&#39;s/ha/HA/2g&#39;</span>	<span class="c1">#指定位置替换，从第2处开替换全局</span>


<span class="c1">#移除匹配样式的行</span>
sed <span class="s1">&#39;/pattern/d
</span><span class="s1">sed &#39;</span>/^$/d<span class="s1">&#39;	##移除空白行
</span><span class="s1">
</span><span class="s1">
</span><span class="s1">#在sed中用&amp;标记已匹配字符串
</span><span class="s1">echo &#34;A wonderful goal&#34; | sed &#39;</span>s/<span class="se">\w\+</span>/<span class="o">[</span><span class="p">&amp;</span><span class="o">]</span>/g<span class="s1">&#39;	#\w\+匹配每一个单词
</span><span class="s1">
</span><span class="s1">
</span><span class="s1">#子串匹配标记\1,\2...
</span><span class="s1">echo &#34;1st 2nd 3rd&#34; | sed &#39;</span>s/<span class="se">\(\w\+\)</span> <span class="se">\(\w\+\)</span> <span class="se">\(\w\+\)</span>/<span class="se">\2</span> <span class="se">\1</span> <span class="se">\3</span>/<span class="s1">&#39;
</span><span class="s1">2nd 1st 3rd
</span><span class="s1">#将\2和\1交换次序，(),+等在sed中要转义，否则要报错
</span><span class="s1">
</span><span class="s1">
</span><span class="s1">#组合多个表达式
</span><span class="s1">sed &#39;</span>expression1<span class="p">;</span> expression2<span class="p">;</span> ...
<span class="nb">echo</span> <span class="s2">&#34;aabbcc&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/a/A/; s/b/B/; s/c/C/g&#39;</span>
AaBbCC


<span class="c1">#双引号 &#34; &#34; 内的特殊符号（如$等），可以保有原本的特性</span>
<span class="c1">#单引号 &#39; &#39; 内的特殊字符则仅为一般字符（纯文本）</span>
<span class="c1">#引用</span>
<span class="nv">text</span><span class="o">=</span>hello
<span class="nb">echo</span> <span class="s1">&#39;hello world&#39;</span> <span class="p">|</span> sed <span class="s2">&#34;s/</span><span class="nv">$text</span><span class="s2">/HELLO/&#34;</span>
HELLO world
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="awk入门">awk入门</h2>
<p><code>awk</code>被设计用于数据流，它可以对列和行进行操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#awk ‘begin{print &#34;start&#34;} pattern {command} end{print &#34;end&#34;}’ file</span>

awk <span class="s1">&#39;{sum += $1}; {print sum}&#39;</span>

<span class="c1">#awk脚本由:begin块、end块和能使用模式(pattern)匹配的通用语句块 组成</span>
<span class="c1">#3个部分都是可选的</span>
<span class="c1">#awk也可以从stdin中读取内容</span>

cat /etc/passwd <span class="p">|</span> awk -F: <span class="s1">&#39;{print $1}&#39;</span>	<span class="c1">#-F指定界定符</span>


<span class="c1">#awk中的特殊变量</span>
<span class="c1">#NR：记录数量(number of records)，对应于当前行号</span>
<span class="c1">#NF：字段数量(number of fields)，对应于当前行的字段数</span>
<span class="c1">#$0：执行过程中当前行的文本内容</span>
<span class="c1">#$1,$2...$NF：第1个/2个.../最后一个 字段的内容</span>

<span class="nb">echo</span> -e <span class="s2">&#34;L1 1\nL2 22\nL3 333&#34;</span> <span class="p">|</span> awk <span class="s1">&#39;{print NR NF $0 $1 $2}&#39;</span>
<span class="c1"># NR NF $0    $1  $2 $NF=最后一个=$2</span>
  <span class="m">1</span>  <span class="m">2</span>  L1 <span class="m">1</span>  L1  <span class="m">1</span>  <span class="m">1</span>
  <span class="m">2</span>  <span class="m">2</span>  L2 <span class="m">2</span>  L2  <span class="m">2</span>  <span class="m">2</span>
  <span class="m">3</span>  <span class="m">2</span>  L3 <span class="m">3</span>  L3  <span class="m">3</span>  <span class="m">3</span>


<span class="c1">#将外部变量传递给awk</span>
<span class="c1">#-v选项可将外部值传递给awk</span>
<span class="c1">#  -v var=val  --assign=var=val</span>

<span class="nv">var</span><span class="o">=</span><span class="s1">&#39;12345&#39;</span>
<span class="nb">echo</span> <span class="p">|</span> awk -v <span class="nv">v1</span><span class="o">=</span><span class="nv">$var</span> <span class="s1">&#39;{print v1}&#39;</span>


<span class="c1">#多个变量</span>
<span class="nv">var1</span><span class="o">=</span>111<span class="p">;</span> <span class="nv">var2</span><span class="o">=</span><span class="m">222</span>
<span class="nb">echo</span> <span class="p">|</span> awk <span class="s1">&#39;{print v1,v2}&#39;</span> <span class="nv">v1</span><span class="o">=</span><span class="nv">$var1</span> <span class="nv">v2</span><span class="o">=</span><span class="nv">$var2</span>


<span class="c1">#变量来自文件而非标准输入</span>
awk <span class="s1">&#39;{print v1,v2}&#39;</span> <span class="nv">v1</span><span class="o">=</span><span class="nv">$var1</span> <span class="nv">v2</span><span class="o">=</span><span class="nv">$var2</span> file


<span class="c1">#用样式对awk进行过滤处理</span>
awk <span class="s1">&#39;NR &lt; 3,NR==4&#39;</span> 1.txt	<span class="c1">#行号&lt;5的行</span>
awk <span class="s1">&#39;/linux/&#39;</span> 1.txt	<span class="c1">#匹配带有linux的行（可用re）</span>
awk <span class="s1">&#39;!/linux/&#39;</span> 1.txt <span class="c1">#!匹配不带linux的行</span>


<span class="c1">#设置定界符</span>
awk -F: <span class="s1">&#39;{print $1}&#39;</span> /etc/passwd
awk <span class="s1">&#39;{FS=&#34;:&#34;} {print $1}&#39;</span> /etc/passwd
awk <span class="s1">&#39;{FS=&#34;:&#34;; print $1}&#39;</span> /etc/passwd


<span class="c1">#从awk中读取命令输出，用getline读取行</span>
<span class="nb">echo</span> <span class="p">|</span> awk <span class="s1">&#39;{&#34;grep root /etc/passwd&#34; | getlin out; print out}&#39;</span>
root❌0:0:root:/root:/bin/bash


<span class="c1">#在awk中使用循环</span>
awk <span class="s1">&#39;{for(i=1;i&lt;4;i++) {print $i}}&#39;</span> 2.txt	<span class="c1">#输出第1,2,3列</span>



<span class="c1">#使用awk删除某列</span>
awk -F<span class="s1">&#39; &#39;</span>    <span class="s1">&#39;{$1=null;$2=null;print}&#39;</span> ./file

</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="对文件中的行单词字符进行迭代">对文件中的行、单词、字符进行迭代</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#迭代文件中的每一行</span>
<span class="nb">echo</span> -e <span class="s2">&#34;1\n22\n333&#34;</span> <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span><span class="k">do</span> <span class="nb">echo</span> <span class="nv">$line</span><span class="p">;</span><span class="k">done</span>
grep <span class="s2">&#34;bash&#34;</span> /etc/passwd <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span><span class="k">do</span> <span class="nb">echo</span> <span class="nv">$line</span><span class="p">;</span><span class="k">done</span>
<span class="c1">#1</span>
<span class="c1">#22</span>
<span class="c1">#333</span>


<span class="c1">#迭代一行中的每一个单词</span>
<span class="nb">echo</span> <span class="s2">&#34;1 22 333&#34;</span> <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span><span class="k">do</span> <span class="k">for</span> word in <span class="nv">$line</span><span class="p">;</span><span class="k">do</span> <span class="nb">echo</span> <span class="nv">$word</span><span class="p">;</span><span class="k">done</span><span class="p">;</span><span class="k">done</span>
<span class="c1">#1</span>
<span class="c1">#22</span>
<span class="c1">#333</span>


<span class="c1">#迭代一个单词中的每一个字符</span>
<span class="nb">echo</span> <span class="s2">&#34;abc&#34;</span> <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span>
<span class="k">do</span>
	<span class="k">for</span> word in <span class="nv">$line</span><span class="p">;</span>
	<span class="k">do</span>
    	<span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span>0<span class="p">;</span>i&lt;<span class="si">${#</span><span class="nv">word</span><span class="si">}</span><span class="p">;</span>i++<span class="o">))</span><span class="p">;</span>
		<span class="k">do</span>
        	<span class="nb">echo</span> <span class="si">${</span><span class="nv">word</span><span class="p">:</span><span class="nv">i</span><span class="p">:</span><span class="nv">1</span><span class="si">}</span><span class="p">;</span>
		<span class="k">done</span><span class="p">;</span>
	<span class="k">done</span><span class="p">;</span>
<span class="k">done</span>

<span class="c1">#写成一行</span>
<span class="nb">echo</span> <span class="s2">&#34;abc&#34;</span> <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="k">for</span> word in <span class="nv">$line</span><span class="p">;</span> <span class="k">do</span> <span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span>0<span class="p">;</span>i&lt;<span class="si">${#</span><span class="nv">word</span><span class="si">}</span><span class="p">;</span>i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="si">${</span><span class="nv">word</span><span class="p">:</span><span class="nv">i</span><span class="p">:</span><span class="nv">1</span><span class="si">}</span><span class="p">;</span> <span class="k">done</span><span class="p">;</span> <span class="k">done</span><span class="p">;</span> <span class="k">done</span>
<span class="c1">#a</span>
<span class="c1">#b</span>
<span class="c1">#c</span>
<span class="c1">#${#word}返回变量word的长度</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="按列合并文件paste">按列合并文件(<code>paste</code>)</h2>
<p>可以使用<code>paste</code>命令实现列拼接</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#paste - merge(整合) lines of files</span>
<span class="nb">echo</span> -e  <span class="s2">&#34;1\n2\n3&#34;</span> &gt; 1.txt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> -e <span class="s2">&#34;Line1\nLine2\nLine3&#34;</span> &gt; 2.txt
paste 1.txt 2.txt
1	Line1
2	Line2
3	Line3
<span class="c1">#默认定界符是制表符，用-d指定</span>
paste 1.txt 2.txt -d<span class="s1">&#39;,&#39;</span>
</code></pre></td></tr></table>
</div>
</div><br>
## 打印文件或行中的第n个单词或n列
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">awk -F<span class="s1">&#39;:&#39;</span> <span class="s1">&#39;{print $1,$3}&#39;</span> file1
cut -d<span class="s1">&#39;:&#39;</span> -f 1,3 file1
</code></pre></td></tr></table>
</div>
</div><br/>
## 打印不同行或样式之间的文本
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">awk <span class="s1">&#39;NR==1,NR==10&#39;</span> /etc/passwd
awk <span class="s1">&#39;NR==1,NR==10&#39;</span> /etc/passwd <span class="p">|</span> awk -F<span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{print $1,$NF}&#39;</span> <span class="c1">#打印特定行内的特定列</span>

awk <span class="s1">&#39;/start_pattern/, /end_pattern/&#39;</span> file	<span class="c1">#打印start到end之间的内容,可使用re</span>
awk <span class="s1">&#39;/root/, /zhang/&#39;</span> /etc/passwd	<span class="c1">#打印root到zhang之间内容</span>
awk <span class="s1">&#39;/^ro.?t&#39;</span>/, /bash$/<span class="err">&#39;</span> /etc/pass
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="以逆序形式打印行">以逆序形式打印行</h2>
<p>可以使用<code>awk</code>, <code>tac</code>完成。tac就是反过来的cat。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#tac - 反转显示文件中的行，行内的内容无法用tac反向排列</span>
tac 1.txt
awk <span class="s1">&#39;{lifo[NR]=$0; lno=NR} END{ for(;lno&gt;-1;lno--) {print lifo[lno]};}&#39;</span> 1.txt
</code></pre></td></tr></table>
</div>
</div><br/>
## 解析文本中的电子邮件和URL
<p>从给定的文件中解析出所需要的文本是我们从事文本处理时的一项任务。</p>
<p>grep, egrep, fgrep - print lines matching a pattern</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#egrep</span>


<span class="c1">#匹配一个邮箱地址</span>
egrep -o <span class="s1">&#39;[a-zA-Z0-9.]+@[0-9a-zA-Z.]+\.[a-zA-Z]{2,4}&#39;</span> emails.txt


<span class="c1">#匹配一个URL地址</span>
egrep -o <span class="s2">&#34;http://[a-zA-Z0-9.]+\.[a-zA-Z]{2,3}&#34;</span> urls.txt
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="打印某个样式之前之后n行grep">打印某个样式之前/之后n行(<code>grep</code>)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">grep <span class="s2">&#34;zhang&#34;</span> /etc/passwd -A 5	<span class="c1">#Ater</span>
grep <span class="s2">&#34;zhang&#34;</span> /etc/passwd -B 5	<span class="c1">#Before</span>
grep <span class="s2">&#34;zhang&#34;</span> /etc/passwd -C 5	<span class="c1">#前后五行都打印</span>
</code></pre></td></tr></table>
</div>
</div><br/>
## 在文件中移除包含某个单词的句子
<p>只要能写出正确的正则表达式(Regular Expression)，那就手到擒来</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">sed <span class="s1">&#39;s/[^.]*handsome boy[^.]*\.//g&#39;</span> file.txt	<span class="c1">#句子以.结束</span>
</code></pre></td></tr></table>
</div>
</div><br>
## 文本切片与参数操作
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#替换变量内容中的部分文字</span>
<span class="nv">var</span><span class="o">=</span><span class="s2">&#34;One two three&#34;</span>
<span class="nb">echo</span> <span class="si">${</span><span class="nv">var</span><span class="p">/t/T</span><span class="si">}</span>	<span class="c1">#只替换了一个</span>
<span class="c1">#One Two three</span>


<span class="c1">#指定字符串起始位置和长度</span>
<span class="c1">#${变量:开始部分:长度}</span>
<span class="si">${</span><span class="nv">vari</span><span class="p">:</span><span class="nv">start</span><span class="p">:</span><span class="nv">length</span><span class="si">}</span>
<span class="nb">echo</span> <span class="o">{</span>var:0:2<span class="o">}</span>	<span class="c1">#On</span>
<span class="nb">echo</span> <span class="o">{</span>var:1:6<span class="o">}</span>	<span class="c1">#ne two</span>


<span class="c1">#起始字符的索引是0,将最后一个字符索引记为-1</span>
<span class="nb">echo</span> <span class="si">${</span><span class="nv">var</span><span class="p">:(-1)</span><span class="si">}</span>	<span class="c1">#e</span>
<span class="nb">echo</span> <span class="si">${</span><span class="nv">var</span><span class="p"><i class="-3" aria-hidden="true"></i></span><span class="nv">3</span><span class="si">}</span>	<span class="c1">#ree</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h1 id="一团乱麻没这回事">一团乱麻？没这回事</h1>
<h2 id="入门">入门</h2>
<p>本章会研究一些用于解析网站内容、下载数据、发送数据表单以及网站颇为任务自动化之类的实例。我们可以仅用几行脚本就将很多原本需要通过浏览器交互进行的活动管理自动化。通过命令行工具利用HTTP协议所提供的功能，我们可以用脚本解决大部分Web自动化的问题。</p>
<br>
<h2 id="网站下载wgetcurl">网站下载(<code>wget</code>,<code>curl</code>)</h2>
<p>使用一些命令行下载工具，从给定的URL中下载文件或网页。<br></p>
<p>wget是一个用于文件下载的命令行工具，选项多且用法灵活。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#Wget - The non-interactive(非交互式) network downloader</span>

wget URL1 URL2...
wget http://xxx.com/nginx-1.12.0.tag.gz
wget https://xxx/a.rpm http://xxxx/bb.rpm


<span class="c1">#指定文件名，指定信息输出(wget默认是stdout)</span>
wget http://mirrors.aliyun.com/repo/Centos-7.repo -O aliyun.repo -o ./wget.log
wget URL -t 5	<span class="c1">#-t，重试次数</span>


<span class="c1">#下载限速</span>
wget --limit-rate<span class="o">=</span>10m URL	<span class="c1">#下载限速</span>
wget -Q 100m URL	<span class="c1">#指定下载配额</span>


<span class="c1">#端点续传</span>
<span class="c1">#wget进行的下载在完成前被中断，从断点开始下载</span>
wget -c URL


<span class="c1">#用cURL下载</span>
<span class="c1">#cURL是一个比wget更强大的高级命令工具</span>
<span class="c1">#和wget不同，curl并不将下载数据写入文件，而是写入stdout，因此必须重定向到文件</span>


<span class="c1">#复制或镜像整个网站</span>
<span class="c1">#wget有一个选项可以使其像爬虫一样以递归方式手机网页上所有URL链接，并逐个下载</span>
<span class="c1">#这样一来就可以下载一个网站的所有页面</span>
wget --mirror URL
<span class="c1">#-m(--mirror) -N -r -l inf --no-remove-listing 的缩写形式。</span>
或 wget -r -N -l DEPTH URL
<span class="c1">#-r递归下载，-l指定递归深度，-N(timestamp)只获取比本地时间新的文件</span>


<span class="c1">#访问需要认证的HTTP或FTP页面</span>
wget --user <span class="s2">&#34;username&#34;</span> --password <span class="s2">&#34;pass&#34;</span> URL
<span class="c1">#如未在命令行内输入密码，则会由网页提示手动输入</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="以格式化纯文本下载网页links">以格式化纯文本下载网页(<code>links</code>)</h2>
<p>网页其实就是包含HTML标记和其他诸如Javascript，CSS等元素的HTML页面。HTML标记是网页的基础，也许需要解析网页来查找特定的内容。<br/></p>
<p>links,是一个基于命令行的Web浏览器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#links - lynx-like alternative character mode WWW browser</span>

<span class="c1">#在命令行中浏览一个网页</span>
links www.baidu.com


<span class="c1">#以ASCII形式下载网页</span>
links --dump URL &gt; URL.txt


<span class="c1">#打开本地html文件</span>
links 1.html
</code></pre></td></tr></table>
</div>
</div><br>
## cURL入门
<p>cURL支持包括HTTP、HTTPS、FTP在内的众多协议。它还支持POST、cookie、认证、从指定偏移处下载部分文件、参照页(referer)、用户代理字符串、扩展头部(extra header)、限速、文件大小限制、进度条等特性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#curl - transfer a URL</span>
<span class="c1">#cURL通常将下载文件输出到stdout，将进度信息输出到stderr</span>
<span class="c1">#要想避免显示进度信息，可使用--silent</span>
<span class="c1">#curl可用来下载、发送各种HTTP请求、指定HTTP头部等操作</span>

curl URL --silent	<span class="c1">#输出到stdout</span>


<span class="c1">#-O写入文件，文件名从URL中解析</span>
curl http://www.baidu.com/index.html -O --silent	<span class="c1">#创建index.html</span>


<span class="c1">#-o将数据写入指定文件</span>
curl URL -o baidu.html --progress	<span class="c1">#--progress显示进度条</span>
links baidu.html


<span class="c1">#端点续传</span>
<span class="c1">#和wget不同，cURL包含更高级的下载恢复特性，能够从特定的文件偏移处继续下载</span>
<span class="c1">#curl可以通过指定一个偏移量来下载部分文件</span>
手动：curl URL/file -C offset	<span class="c1">#偏移量以Byte为单位的整数</span>
自动：curl -C -URL	<span class="c1">#自动续传</span>


<span class="c1">#用cURL设置参照页字符串, --referer</span>
<span class="c1">#参照页(referer)是位于HTTP头部中的一个字符串，用来标识用户从哪个页面到达当前页面的</span>
<span class="c1">#如果用户点击网页A中某个链接，转到了网页B。那么网页B头部的referer会包含网页A的URL</span>
curl --referer Referer_URL target_URL
curl --referer http://www.baidu.com http://jianshu.com


<span class="c1">#用cURL设置cookie, --cookie</span>
<span class="c1">#可以用curl来存储HTTP操作过程中使用到的cookie</span>
<span class="c1">#cookie用key=value形式，指定多个用 分号 分隔</span>
curl URL --cookie <span class="s2">&#34;user=AAA;name=bbb&#34;</span>
curl URL --cookie-jar cookie.txt	<span class="c1">#将cookie另存为</span>


<span class="c1">#用cURL设置用户代理字符串, --user-agent</span>
<span class="c1">#如果不指定代理，一些需要用户代理的网页就无法显示</span>
curl URL --user-agent<span class="o">(</span>-A<span class="o">)</span> <span class="s2">&#34;Mozilla&#34;</span>


<span class="c1">#用-H &#34;头部信息&#34;传递多个头部信息</span>
curl -
H <span class="s2">&#34;Host:www.haha.com&#34;</span> -H <span class="s2">&#34;Accept-language: en&#34;</span> URL

<span class="c1">#限定cURL可占用的带宽</span>
curl URL --limit-rate 10m


<span class="c1">#指定最大下载量</span>
curl URL --max-filesize 大小<span class="o">(</span>Bytes<span class="o">)</span>


<span class="c1">#用cURL进行认证，-u username:password指定用户名和密码</span>
curl -u user:pass URL
curl -u user URL	<span class="c1">#手动输入密码</span>


<span class="c1">#只打印响应头部信息(无数据部分), -I</span>
curl -I URL
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="从命令行访问163邮箱">从命令行访问163邮箱</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">curl -u user http://mail.163.com
<span class="c1">#手动输入密码</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="制作图片抓取器及下载工具">制作图片抓取器及下载工具</h2>
<p>可以用脚本解析图像文件并将图片自动下载下来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">curl -s URL <span class="p">|</span> grep -o <span class="s2">&#34;&lt;img src=[^&gt;]*&gt;&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/&lt;img src=//g; s/&gt;//g&#39;</span> &gt; img.list
<span class="c1">#匹配图片的URL，可能还需要细化修改</span>
<span class="c1">#不同的URL可能有不同的规则，根据实际情况取出img的URL</span>


<span class="c1">#下载图片</span>
wget <span class="nv">$URL</span> 或 curl -s -O <span class="nv">$URL</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="查找网站中的无效链接lynx">查找网站中的无效链接(<code>lynx</code>)</h2>
<p>将查找无效链接的工作自动化，那就比纯手动厉害多了！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">lynx -traversal URL <span class="c1">#会将URL中所有链接生成到reject.dat文件中</span>
sort -u reject.dat <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> link
<span class="k">do</span>
	<span class="nv">output</span><span class="o">=</span><span class="sb">`</span>curl -I <span class="nv">$link</span> -s <span class="p">|</span> grep <span class="s2">&#34;HTTP/.*OK&#34;</span><span class="sb">`</span>
    <span class="k">if</span> <span class="o">[[</span> -z <span class="nv">$output</span> <span class="o">]]</span>
    <span class="k">then</span>
    	<span class="nb">echo</span> <span class="nv">$link</span>
    <span class="k">fi</span>
<span class="k">done</span> &lt; links.txt
</code></pre></td></tr></table>
</div>
</div><br>
## 跟踪网站变更(`curl+diff`)
<p>可以编写一个定期运行的变更跟踪器(change tracker)，一旦发生变更，跟踪器便会发出声音或发送提示信息。
在不同时间检索网站，然后利用 <code>diff</code> 命令进行比对。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">curl URL --silent -o <span class="sb">`</span>date +%F<span class="sb">`</span>.html	<span class="c1">#第一次</span>
curl URL --silent -o <span class="sb">`</span>date +%F<span class="sb">`</span>.html	<span class="c1">#第二次</span>
diff -u 第一次 第二次
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="以post方式发送网页并读取响应">以POST方式发送网页并读取响应</h2>
<p>POST 和 GET 是HTTP协议中用于发送或检索信息的两种请求类型。
在GET请求方式中，利用网页的URL来发送参数(“键-值”)；而POST方式用于提交表单，如提交用户名、密码以及检索登录页面等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">curl URL -d “postarg<span class="o">=</span>AABBCC” <span class="c1">#-d,http post data</span>
curl URL -d <span class="s2">&#34;post1=key1&amp;post2=key2&amp;post3...&#34;</span>	<span class="c1">#指定多个数据</span>

wget URL -post-data <span class="s2">&#34;post1=key1&#34;</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h1 id="plan-b">Plan B</h1>
<br>
<h2 id="简介-5">简介</h2>
<p>提取快照和备份数据都是重要的工作，我们可以通过shell脚本来实现备份自动化。
归档和压缩对于SA来说同样很重要，有多种压缩格式。
加密是一种保护数据的方法，为了减少加密数据的大小，文件在加密前通常需要先归档和压缩。</p>
<br/>
<h2 id="用tar归档">用<code>tar</code>归档</h2>
<p><code>tar</code>命令可以用来归档文件(tar archives tar)。可以将多个文件和文件夹打包为单个文件，同时还能保留所有的文件属性。
由<code>tar</code>命令创建的文件通常称为tarball。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#归档文件，-c(create file)</span>
tar -cf 1.tar <span class="o">[</span>sources<span class="o">]</span>	<span class="c1">#-f(specify filename)指定文件名</span>


<span class="c1">#文件名必须紧跟在-f之后</span>
tar -cvf txt.tar *.txt	<span class="c1">#-v(verbose)详细信息</span>


<span class="c1">#向已归档文件中添加文件，-r</span>
tar -rvf txt.tar *.html


<span class="c1">#列出归档文件中的内容，-t</span>
tar -tf txt.tar	<span class="c1">#列出归档内容</span>
tar -tvf txt.tar	<span class="c1">#列出内容详细信息</span>


<span class="c1">#从归档文件中提取文件或文件夹，-x(exact)</span>
tar -xf txt.tar	<span class="c1">#默认提取到当前目录</span>
<span class="c1">#-C指定提取目录</span>
tar -xvf txt.tar -C /dir/path
<span class="c1">#只提取归档中特定文件</span>
tar -xf txt.tar 1.txt 1.html -C /tmp	<span class="c1">#只会提取1.txt和1.html文件</span>


<span class="c1">#在tar中使用stdin和stdout</span>
tar -cvf - *.text <span class="p">|</span> tar -xvf - -C /tmp


<span class="c1">#拼接两个归档文件，-A</span>
tar -Af txt.tar html.tar
tar -tvf txt.tat	<span class="c1">#验证是否成功</span>


<span class="c1">#添加选项，可以将指定的任意文件加入到归档文件中。如果同名文件已存在，不会覆盖源文件，那么结果就是归档中包含了多个同名文件</span>
<span class="c1">#通过检查时间戳来更新对党文件中的内容，-u</span>
<span class="c1">#只有比归档文件中同名文件 更新(newer) 才添加</span>
tar -uvf html.tar 1.html


<span class="c1">#比较归档文件与文件系统中的内容，-d</span>
tar -df txt.tar 1.txt 2.txt


<span class="c1">#从归档文件中删除文件，--delete</span>
tar -f txt.tar --delete 1.txt 2.txt


<span class="c1">#从归档文件中排除部分文件,--exclude</span>
tar -cf all.tar ./* --exclude<span class="o">=</span><span class="s2">&#34;*.html&#34;</span>	<span class="c1">#排除.html文件</span>
tar -cvf txt.tar *.txt --exclude<span class="o">=</span><span class="s2">&#34;1.txt&#34;</span>


<span class="c1">#打印总字节数,--totals</span>
tar -cf all.txt ./* --totals


<span class="c1">#压缩tar归档文件，指定不同压缩格式</span>

<span class="c1">#-z,	.tar.gz</span>
<span class="c1">#-j,	.tar.bz2</span>
<span class="c1">#--lzma,	.tar.lzma,</span>
<span class="c1">#.tar.lzo</span>
tar -czvf txt.tar.gzip *.txt
tar -xzvf txt.tar -C /dir/path


<span class="c1">#tar后删除原文件</span>
tar -czvf txt.tar.gz ./txt --remove-files
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="用cpio归档">用<code>cpio</code>归档</h2>
<p><code>cpio</code>是类似于tar的另一种归档格式。它多用于RPM软件包、Linux内核和initramfs文件等。
cpio通过stdin获取输入，并将归档写入stdout。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">touch file<span class="o">{</span>1..4<span class="o">}</span>

<span class="nb">echo</span> file1 file2 file3 file4 <span class="p">|</span> cpio -ov file.cpio
<span class="c1">#-o指定输出，-v打印归档文件列表</span>


<span class="c1">#-i指定输入，-t列出归档中文件</span>
cpio -it &lt; file.cpio
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="用gunzip或gzip压缩">用<code>gunzip</code>或<code>gzip</code>压缩</h2>
<p>gzip是GNU/Linux下常用压缩格式。<code>gzip</code>,<code>gunzip</code>都可处理gzip压缩文件类型。
<code>gzip</code>只能够压缩单个文件，而无法对目录和多个文件进行归档。因此需要先交给<code>tar</code>，然后再用<code>gzip</code>压缩</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">gzip file	<span class="c1">#file.gz，会覆盖原文件</span>
gunzip file.gz	<span class="c1">#file，也会删除原文件</span>


<span class="c1">#列出压缩文件的属性信息，-l</span>
gzip -l file.gz


<span class="c1">#指定gzip的压缩级别，--fast或--best</span>
--fast	最低压缩比，最快速度完成
--best	最高压缩比，最慢速度完成


<span class="c1">#将gzip与归档文件结合，-z</span>
tar -czvf txt.tar.gzip ./*.txt
<span class="c1">#-a指定从文件扩展名自动判断压缩格式</span>
tar -cavf txt.tar.gzip ./*.txt


<span class="c1">#tar只能从命令行中接收有限个文件，要解决这个问题，可以写一个循环并添加-r选项</span>


<span class="c1">#解压缩，-x</span>
tar -xzvf txt.tar.gzip
tar -xavf txt.tar.gzip -C /dir/path
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="用bunzip或bzip压缩">用<code>bunzip</code>或<code>bzip</code>压缩</h2>
<p><code>bzip2</code>通常能够生成比gzip更小(压缩比更高)的文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">bzip2 file	<span class="c1">#file.bz2,同理会覆盖原文件</span>
bzip2 file -k	<span class="c1">#保留原文件</span>
bunzip2 file.bz2	<span class="c1">#解压缩</span>
bunzip file.bz2 -k


<span class="c1">#从stdin读入并写到stdout</span>
cat file <span class="p">|</span> bzip2 -c &gt; file.bz2


<span class="c1">#将bzip2与归档文件结合，-j</span>
tar -cvjf 1.tar.bz2 ./1.*
tar -cavf 1.tar.bz2 ./1.*	<span class="c1">#-a根据文件扩展名自动判断压缩格式</span>
tar -xjvf 1.tar.bz2
tar -xavf 1.tar.bz2 -C /tmp


<span class="c1">#压缩比</span>
<span class="c1">#从1级(速度最快，压缩率最低)到9级</span>
bzip -9 -k file


<span class="c1">#对成千上万的文件进行归档，需要借助 循环和-r选项</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="lzma压缩"><code>lzma</code>压缩</h2>
<p><code>lzma</code>是一个较新的压缩工具，它提供了比gzip或bzip2更好的压缩率。
xz, unxz, xzcat, lzma, unlzma, lzcat - Compress or decompress .xz and .lzma files</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">lzma file	<span class="c1">#file.lzma,同样也会删除原文件</span>
lzma file -k 	<span class="c1">#保留原文件</span>
unlzma file.lzma

<span class="c1">#从stdin读入并写入stdout</span>
cat file <span class="p">|</span> lzma -C &gt; file.lzma

<span class="c1">#与tar相结合,--lzma</span>
tar -cvf 1.tar.lzma ./1.* --lzma
tar -cavf 1.tat.lzma ./1.*	<span class="c1">#自动判断</span>
tar -xvf 1.tar.lzma --lzma
tar -xavf 1.tar.lzma -C /tmp

<span class="c1">#压缩率</span>
<span class="c1">#从1级到9级(压缩级别最高，速度最慢)</span>

<span class="c1">#对成千上万的文件，需要使用循环和-r选项</span>
</code></pre></td></tr></table>
</div>
</div><br>
## zip归档和压缩
<p><code>zip</code>在Linux下不如<code>gzip</code>,<code>bzip2</code>那么广泛，但在Internet上的文件通常都采用这种格式。
zip - package and compress (archive) files</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">zip file.zip file
unzip file.zip
<span class="c1">#与lzma,gzip,bzip2相比，zip完成后不会删除原文件</span>


<span class="c1">#对目录和文件进行递归操作,-r</span>
zip -r dir.zip /root/test ./file


<span class="c1">#向归档文件中增加内容，-u</span>
zip dir.zip -u newfile


<span class="c1">#从压缩文件中删除内容，-d</span>
zip -d dir.zip file


<span class="c1">#列出归档文件中内容</span>
unzip -l dir.zip
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="超高压缩率的squashfs文件系统">超高压缩率的<code>squashfs</code>文件系统</h2>
<p><code>squashfs</code>是一种只读型的超高压缩率文件系统。这种文件系统能够将 2GB-3GB的数据压缩成一个700MB的文件。
你有没有想过Linux Live CD是怎样运行的？当Live CD启动后，它会加载一个完整的Linux环境。这就是利用了一种被称为squashfs的只读型压缩文件系统。它将根文件系统保存在一个压缩过的文件系统文件中。这个文件可以使用环回的形式来挂载并对其中的文件进行访问。一次当进程需要某些文件，可以将它们解压，然后载入内存中使用。
如果需要构建一个定制的Live OS，或是需要超高压缩率的文件并且无需解压就可以访问文件，那么squashfs的相关知识就能派上用场。要解压个头较大的压缩文件，需要花费不少时间。但如果将文件以环回形式挂载，速度就飞快，因为只有出现访问请求的时候，对应的那部分压缩文件才会被解压缩。而普通的解压缩方式是首先解压缩所有的数据。</p>
<p>环回文件系统就是指那些在文件中而非物理设备中创建的文件系统。比如我们可以创建一个文件，然后把这个文件格式化为我们常见ntfs、exfat或者ext4等文件系统格式，然后把它挂载在一个目录上使用。</p>
<p>如果你有一张Ubuntu CD，可以在CDRom Root/casper/filesystem.squashfs中找到文件.squashfs。
squashfs在内部采用了gzip和lzma这类压缩算法。</p>
<p>mksquashfs - tool to create and append to squashfs filesystems</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">yum install squashfs-tools -y

<span class="c1">#创建squashfs文件</span>
mksquashfs <span class="nb">source</span> compressfile.squashfs

mksquashfs /etc etc.squashfs
<span class="c1">#/etc(67M) --&gt; etc.suqashfs(18M)</span>


<span class="c1">#要挂载squashfs文件，利用环回形式进行挂载</span>
mkdir /mnt/squash
mount -o loop etc.squashfs /mnt/squash
<span class="c1">#此处挂载使用etc.squashfs文件系统</span>
<span class="c1">#如果直接查看etc.squashfs，就是一个普通文件，但是挂载以后所有文件都出现了</span>
umount /mnt/squash


<span class="c1">#在创建squashfs文件时排除指定文件，-e</span>
mksquashfs /etc etc.squashfs -e /etc/passwd /etc/shadow /etc/*.txt
<span class="c1">#在挂载之后就没有相关文件了</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="加密工具与散列">加密工具与散列</h2>
<p>加密技术主要用于防止数据遭受未经授权的访问。
Linux下某些工具用于执行加密和解密，使用加密算法散列值来验证数据完整性。</p>
<p><strong><code>crypt</code>, <code>gpg</code>, <code>base64</code>, <code>md5sum</code>, <code>sha1sum</code>, <code>openssl</code>的用法</strong></p>
<h3 id="ccypt"><code>ccypt</code></h3>
<p>ccrypt是为了取代UNIX crypt而设计的，这个实用工具可用于文件和数据流加密及解密。</p>
<p>ccrypt - encrypt and decrypt files and streams</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">ccrypt 1.txt	<span class="c1">#会要求输入口令(encryption key)</span>
<span class="c1">#之后会生成1.txt.cpt覆盖原文件</span>


<span class="c1">#更改key,-x</span>
ccrypt -x 1.txt.cpt	<span class="c1">#输入old key和new key</span>


<span class="c1">#解密，-d(--decrypt)</span>
ccrypt -d 1.txt.cpt	<span class="c1">#输入key解密</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="gpg"><code>gpg</code></h3>
<p>gpg(GNU privacy guard,GNU隐私保护)，是一种应用广泛的加密方案。
它采用签名密钥技术保护文件内容，只有经过认证的用户才能访问数据。我们对gpg签名早已耳熟能详。</p>
<p>gpg - OpenPGP encryption and signing tool</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#加密，-c(--symmetric)对称加密</span>
gpg -c file	<span class="c1">#会要求输入口令(Passphrase)，生成file.gpg</span>

<span class="c1">#解密</span>
gpg file.gpg
</code></pre></td></tr></table>
</div>
</div><h3 id="base64"><code>base64</code></h3>
<p><code>base64</code>是一组类似的编码方案(encoding scheme)，它通过将ASCII字符转换成以64为基数的形式(radix-64 representation)来用ASCII字符串描述二进制数据。base64可用来对 编码和解码 base64字符串。</p>
<p>base64 - base64 encode/decode data and print to standard output</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#将文件编码为base64格式</span>
base64 file &gt; outputfile
cat file <span class="p">|</span> base64 &gt; outputfile

<span class="c1">#解码,-d</span>
base64 -d outputfile &gt; file
</code></pre></td></tr></table>
</div>
</div><h3 id="md5sum与sha1sum"><code>md5sum</code>与<code>sha1sum</code></h3>
<p><code>md5sum</code> 和 <code>sha1sum</code> 都是单向散列算法(unidirecrional hash algorithm)，均无法逆推出原始数据。
它们通常用于验证数据完整性或为特定数据生成唯一的密钥，因为通过分析文件内容，它们可以为每个文件生成一个唯一的密钥。</p>
<p>这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。
将密码以明文的形式存储是非常危险的事情，它面临密码泄露的危险。而因为 md5sum和sha1sum 是单向散列算法，所以密码使用散列值存储是很安全的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">echo</span> <span class="s2">&#34;1.txt&#34;</span> &gt; 1.txt
md5sum 1.txt	<span class="c1">#生成密钥到stdout</span>
<span class="c1">#39061daa34ca3de20df03a88c52530ea  1.txt</span>


sha1sum file	<span class="c1">#生成密钥到stdout</span>
<span class="c1">#659fcbc505db207c03b5c4c0b6981d63286abe21  1.txt</span>


<span class="c1">#查看/etc/shadow中密码的散列值</span>
awk <span class="s1">&#39;NR==1&#39;</span> /etc/shadow <span class="p">|</span> awk -F: <span class="s1">&#39;{print $2}&#39;</span>	<span class="c1">#root密码散列</span>
<span class="c1">#$6$BxpV48gPsjuq6.pF$wE7pUDwtOI.v64kd5folG68yUt2UAQDTUGgKa5Iz69GaupEoRAdCeerP8nRKXo48c4azutUCGhnDgzd1qe8YX0</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="shadowlike散列salted散列">shadowlike散列(salted散列)</h3>
<p>shadow密码通常都是salted密码，所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不同里被破解。salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salted散列值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#/etc/passwd里面的密码散列类型就是salted散列</span>


<span class="c1">#查看root密码对应的散列值</span>
head -1 /etc/shadow
root:<span class="nv">$6$ZlHRCZG2iRwQUXAu$RAEDH97nPdZB2RK20npua6Qf6jB7osatoC99ow3LtPQ6aORdLISYC7</span>/4iTYU162emkQLt4ZafdgjyAeoSB7IU0::0:99999:7:::


<span class="c1">#openssl - OpenSSL command line tool</span>

<span class="c1">#shadow密码是使用openssl生成</span>
<span class="c1">#将SALT_STRING替换为随机字符串，同时将pass替换成你想测试的密码</span>
openssl -1 -salt SALT_STRING passwd
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="用rsync备份系统">用<code>rsync</code>备份系统</h2>
<p><code>rsync</code>借助差异计算以及压缩技术来最小化数据传输量。相较于<code>cp</code>命令，它的优势在于使用了高效的差异算法(difference algorithm)。
它还支持网络数据传输。在进行复制的同时，rsync会比较源端和目的端的文件，只有当文件有更新是才进行复制。默认情况下，rsync并不会在目的端删除源端已不存在的文件。</p>
<p>rsync - a fast, versatile, remote (and local) file-copying tool
inotifywait - wait for changes to files using inotify</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#-a进行归档，-v详细信息</span>
rsync -av <span class="nb">source</span> destination
rsync -av /etc /tmp


<span class="c1">#异地cp</span>
rsync -av <span class="nb">source</span> username@host:PATH
rsync -av username@host:PATH destination
<span class="c1">#rsync借助于ssh，可以使用ssh无秘钥认证</span>
rsync -av /etc zhang@192.168.1.11:~

<span class="c1">#-z, --compress  compress file data during the transfer</span>
rsync -avz zhang@192.168.1.11:/etc /tmp


<span class="c1">#注意，路径格式</span>
rsync /etc /tmp	<span class="c1">#整个/etc目录</span>
rsync /etc/ /tmp	<span class="c1">#/etc目录下所有内容</span>


<span class="c1">#显示进度，--progress</span>
rsync -avz --progress /etc /tmp


<span class="c1">#排除部分文件，--exclude</span>
rsync -avz /etc /tmp --exclude<span class="o">=</span>/etc/nginx --exclude <span class="s2">&#34;*.txt&#34;</span>


<span class="c1">#更新rsync时，删除不存在的文件，--delete</span>
<span class="c1">#默认情况下，rsync并不会在目的端删除源端已不存在的文件</span>
rsync -avz /etc zhang@192.168.1.1:~ --delete


<span class="c1">#定期调度</span>
crontab -e
<span class="m">0</span> */10 * * * rsync -avz /etc user@host:PATH


<span class="c1">#实时同步，inotifywait+rsync</span>
yum install inotify-tools -y

<span class="c1">#-m(monitor),-r(recursive),-q(--quiet)静默模式，-e(event)</span>

vi inotify_rsync.sh
inotifywait -mrq -e creat,delete,modify,move --exclude <span class="s2">&#34;^.*\.filepart</span>$<span class="s2">&#34;</span> /etc <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> file
<span class="k">do</span>
rsync -az --exclude<span class="o">=</span><span class="s2">&#34;.*&#34;</span> --exclude<span class="o">=</span><span class="s2">&#34;*.swp&#34;</span> --exclude<span class="o">=</span><span class="s2">&#34;.filepart&#34;</span> --delete /etc /tmp &gt; /dev/null 2&gt;<span class="nv">$1</span>
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><br/>
## 用Git备份版本控制
<p>维护和恢复变更最好的方法是使用版本控制系统。由于代码变更频繁，版本控制系统多用于软件开发和代码维护。
Git(GNU it)是有名气也是最高效的版本控制系统。我们可在非编程环境下用Git备份普通文件。</p>
<p>git - the stupid content tracker</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">mkdir /home/zhang/gittest
<span class="nb">cd</span> /home/zhang/gittest



<span class="c1">#在源主机中添加用户信息</span>
git config --global user.name <span class="s2">&#34;username&#34;</span>	<span class="c1">#设置用户名</span>
git config --global user.email <span class="s2">&#34;someone@example.com&#34;</span>	<span class="c1">#设置邮箱</span>


<span class="c1">#创建一个空的Git版本库或初始化一个老版本</span>
git init


<span class="c1">#记录变更到版本库</span>
git commit


<span class="c1">#添加远程git目录并同步备份</span>
git remote add origin user@host:/home/zhang/gittest


<span class="c1">#为git跟踪(git tracking)添加或删除文件</span>
<span class="c1">#add,添加内容至索引</span>
git add *
<span class="c1">#git add *.txt; git add *.ph	#添加部分文件</span>


<span class="c1">#删除不需要跟踪的文件和文件夹</span>
<span class="c1">#rm,从工作去和索引删除文件</span>
git rm file
<span class="c1">#git rm *.txt</span>


<span class="c1">#检查点或创建备份点(check point)</span>
git commit -m <span class="s2">&#34;Commit Message&#34;</span>


<span class="c1">#push,更新远程</span>
git push


<span class="c1">#用Git恢复数据</span>
<span class="c1">#log,显示提交日志</span>
git log


<span class="c1">#返回之前某个版本或状态</span>
git checkout xxxxxxxx<span class="o">(</span>Commit ID<span class="o">)</span>


<span class="c1">#clone,克隆一个版本库到本地</span>
git clone URL
git clone user@host:PATH
</code></pre></td></tr></table>
</div>
</div><br>
## 用`dd`克隆磁盘
<p><code>dd</code>命令能用于克隆任何类型的磁盘，如硬盘、闪存、CD、DVD及软盘。
可能需要创建所有分区的副本而不仅仅是复制内容，包括硬盘分区、引导记录、分区表等信息。</p>
<p>使用dd的时候，要留意参数的顺序。错误的参数会损毁全部数据。dd基本上算是一个比特流复制器(bitstream duplicator),它可以将来自磁盘的比特流写入文件，也可以将来自文件的比特流写入硬盘。</p>
<p>dd - convert and copy a file</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">dd <span class="k">if</span><span class="o">=</span><span class="nb">source</span> <span class="nv">of</span><span class="o">=</span>target <span class="nv">bs</span><span class="o">=</span>block_size <span class="nv">count</span><span class="o">=</span>count
<span class="c1">#bs块大小，count块数</span>

dd <span class="k">if</span><span class="o">=</span>/tmp/centos7.iso <span class="nv">of</span><span class="o">=</span>/dev/sdc


<span class="c1">#/dev/zero是一个字符设备，它总是返回字符&#39;\0&#39;</span>
dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>./file <span class="nv">bs</span><span class="o">=</span>10m <span class="nv">count</span><span class="o">=</span><span class="m">100</span>


<span class="c1">#用环回(loop back)方法可将任何由dd生产的文件镜像进行挂载</span>
mount -o loop file /mnt
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h1 id="无网不利">无网不利</h1>
<h2 id="简介-6">简介</h2>
<p>网络是计算机系统中重要的部分。我们以Tcp/Ip为协议栈，所有操作都是基于它进行的。</p>
<p>一些使用网络的应用通过打开并连接到防火墙端口进行运作，而有的管理任务可以通过网络进行。</p>
<br>
<h2 id="网络小知识">网络小知识</h2>
<p>网络接口(Interface)用来连接网络。在每个系统中，默认都有一个称之为环回接口的lo，这个接口指向当前主机本身。
操作系统维护者一个被称为路由表(routing table)的表格，它包含了分组如何转发以及通过网络中的哪些节点转发的消息。
metric是路由算法用以确定到达目的地的最佳路径的计量标准，如路径长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#显示网络接口、子网掩码等详细信息</span>
ifconfig	<span class="c1">#/sbin/ifconfig</span>


<span class="c1">#显示某个特定接口</span>
ifconfig eth0


<span class="c1">#提取IP地址</span>
ifconfig eth0 <span class="p">|</span> egrep -o <span class="s2">&#34;inet [^ ]*&#34;</span> <span class="p">|</span> grep -o <span class="s2">&#34;[0-9.]*&#34;</span>


<span class="c1">#设置网络接口的IP地址和子网掩码</span>
ifconfig eht0 192.168.1.11
ifconfig eth0 192.168.1.11 netmask 255.255.255.0
<span class="c1">#远程的时候，千万别乱改IP，不然连不上你就要去机房了</span>


<span class="c1">#MAC地址欺骗</span>
ifoconfig eth0 hw ether 11:22:33:44:55:66


<span class="c1">#域名服务器与DNS</span>
cat /etc/resolv.conf
<span class="c1">#添加域名服务器</span>
<span class="nb">echo</span> <span class="s2">&#34;name 114.114.114.114&#34;</span> &gt;&gt; /etc/resolv.conf
<span class="c1">#nameserver 114.114.114.114</span>


<span class="c1">#一个域名可以分配多个地址，DNS只会返回其中一个</span>
<span class="c1">#要想获得域名所有IP地址，需要使用DNS查找工具</span>


<span class="c1">#DNS查找工具</span>
host www.baidu.com
nslookup www.baidu.com


<span class="c1">#自定义解析</span>
cat /etc/hosts
<span class="nb">echo</span> <span class="s2">&#34;192.168.1.11 www.zhang.me&#34;</span> &gt;&gt; /etc/hosts


<span class="c1">#设置默认网关，显示路由表信息</span>
<span class="c1">#路由表</span>
route
route -n	<span class="c1">#以数字形式显示地址</span>


<span class="c1">#设置默认网关</span>
route add default gw <span class="nv">$ip</span> <span class="nv">$interface</span>
route add default gw 192.168.1.1 eht0


<span class="c1">#显示分组途经的所有网关地址</span>
traceroute www.baidu.com
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="ping"><code>ping</code></h2>
<p><code>ping</code>使用 **网际控制报文协议(Internet Control Message Protocol,ICMP)**的echo分组。如果分组能够送达且该主机为活动主机，那它就会发送一条回应。一旦主机不可到达，ping返回错误信息&quot;Destination Host Unreachable&quot;。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">ping 192.168.1.1

<span class="c1">#往返时间(Round Trip Time,RTT)</span>

<span class="c1">#发送分组数量</span>
ping <span class="nv">$URL</span> -c <span class="m">6</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="列出网络上所有活动主机">列出网络上所有活动主机</h2>
<p>当涉及大型局域网时，可能需要检查网络上的其他主机的活动状态。
一台非活动主机可能是：没有开机；网络连接有问题；主机禁ping；防火墙问题。</p>
<p>当我们要检测ip时，在一个脚本中，每一次<code>ping</code>都是依次执行。即使所有的ip地址都是彼此独立，由于编写的是顺式程序(sequential program)，<code>ping</code>命令也只能按顺序执行。每次执行一个<code>ping</code>命令。都要经历一段延迟——“发送echo分组，并接收或等待回应超时”。</p>
<p>要是处理几百个ip地址的话，这个延时就真不短了。我们可以使用并行方式来加速所有ping命令的执行。
可以将<code>ping</code>命令中的循环体放入**( )&amp;** 中，**( )** 使其中的命令可作为子shell来执行，**&amp;** 使之在后台继续运行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#编写G一个并行方式的ping脚本</span>
fo ip in 192.168.1.<span class="o">{</span>1..255<span class="o">}</span>
<span class="k">do</span>
	<span class="o">(</span>
	ping <span class="nv">$ip</span> -c2 <span class="p">&amp;</span>&gt; /dev/null<span class="p">;</span>
	<span class="k">if</span><span class="o">[</span> <span class="nv">$?</span> -eq <span class="m">0</span> <span class="o">]</span>
		<span class="k">then</span>
			<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$ip</span><span class="s2"> is alive&#34;</span>
	<span class="k">fi</span>
	<span class="o">)</span><span class="p">&amp;</span>
<span class="nb">wait</span>
<span class="k">done</span>
<span class="c1">#wait命令是脚本只有在所有子进程或后台进程全部终止或完成后才能结束</span>


<span class="c1">#使用fping,-a显示活动主机，-g生成目标列表,-u显示无法到达主机</span>
fping -a 192.168.0.0/24 -g 2&gt; /dev/null
fping -a 192.168.0.1 192.168.3.255 -g 2&gt; ./unreach.txt
<span class="c1">#将unreach主机找出</span>
cat unreach.txt <span class="p">|</span> egrep -o <span class="s2">&#34;to [0-9.]+</span>$<span class="s2">&#34;</span> <span class="p">|</span> grep -o <span class="s2">&#34;[0-9.]*&#34;</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="传输文件">传输文件</h2>
<p>有很多不同的方法可以在网络节点上传输文件，常见的协议有<strong>FTP, SFTP, RSYNC, SCP</strong>。</p>
<p>通过FTP传输文件可使用<code>lftp</code>命令；
通过SSH传输文件可使用<code>sftp</code>；
RSYNC使用<code>SSH</code>与<code>rsync</code>命令；
<code>scp</code>通过SSH进行传输。</p>
<br>
<p>文件传输协议(File Transfer Protocol, FTP)，使用21端口。FTP是明文传输，So&hellip;
需要远程主机上启用了FTP服务器才能使用FTP。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">lftp user@ftp-host
<span class="c1">#输入密码后便可以操作如下命令</span>
<span class="nb">cd</span> -- lcd<span class="o">(</span>本地<span class="o">)</span>
mkdir
get filename	<span class="c1">#下载文件</span>
put filename	<span class="c1">#上传文件</span>
quit	<span class="c1">#退出</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<p>SFTP(Secure FTP,安全FTP)，运行在SSH连接之上。利用SSH连接模拟FTP接口。
它不需要源端运行FTP服务器，不要运行OpenSSH。SFTP是一个交互式命令，提供了命令提示符。</p>
<p>rsync广泛用于网络文件与系统快照的备份。</p>
<p>SCP(Secure Copy,安全复制)，远程文件复制工具。通过SSH加密通过进行传输。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">scp SOURCE DESTINATION

scp /path/file user@host:PATH
scp usr@host:/dir/file /home/zhang
<span class="c1">#需要输入密码，可以用SSH无秘钥认证</span>

<span class="c1">#-r递归复制,-p保持文件权限和模式</span>
scp -r /etc user@host:/tmp
scp -rp user@host:/var/www  /var
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="ssh无秘钥认证">SSH无秘钥认证</h2>
<p>特别是在定时任务传输备份文件时，无秘钥认证就很方便了。SSH服务默认在22端口，你可以在配置文件中修改。</p>
<p>具体步骤：</p>
<ol>
<li>创建SSH密钥(公钥和私钥)；</li>
<li>将客户端公钥上传给需要连接的主机，并写入~/.ssh/authorized_keys文件；</li>
<li>修改相关目录(700)和文件权限(600)；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">ssh-keygen -t rsa
<span class="c1">#后续操作默认即可</span>
<span class="c1">#生成~/.ssh/id_rsa.pub和id_rsa</span>


<span class="c1">#写入远程主机</span>
ssh user@host <span class="s2">&#34;cat &gt;&gt; ~/.ssh/authorized_keys&#34;</span> &lt; ~/.ssh/id_rsa.pub
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="用ssh在远程主机上运行命令">用SSH在远程主机上运行命令</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#连接远程主机</span>
ssh user@host


<span class="c1">#非默认端口</span>
ssh user@host -p <span class="m">2211</span>


<span class="c1">#在远程主机中运行命令</span>
ssh user@host <span class="s1">&#39;command&#39;</span>
ssh user@host <span class="s1">&#39;cmd1&#39;</span><span class="p">;</span> <span class="s1">&#39;com2&#39;</span>...

ssh user@host <span class="s1">&#39;whoami&#39;</span>


<span class="c1">#-C压缩功能，当带宽有限时</span>
ssh -C user@host <span class="s1">&#39;cmd&#39;</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="在本地挂载远程驱动器sshfs">在本地挂载远程驱动器(<code>sshfs</code>)</h2>
<p>在执行读写数据操作时，通过本地挂载远程主机文件系统。利用SSH和sshfs来实现这一功能。
sshfs是FUSE文件系统的一个扩展，FUSE允许其支持的操作系统像使用本地文件系统一样挂载各类数据。
<code>sshfs</code>允许将远程文件系统挂载到本地挂载点上。</p>
<p>相当于便捷的NFS，但并不需要搭建NFS服务。</p>
<p>SSHFS - filesystem client based on ssh</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#挂载远程文件到本地</span>
ssh user@host:PATH /mnt/sshfs

umout /mnt/sshfs
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="网络流量和端口分析">网络流量和端口分析</h2>
<p>应用程序在主机上打开端口，然后与远程主机中打开的端口实现通信。
出于安全方面的考虑，必须留意系统中打开及关闭的端口。</p>
<p>恶意软件和rootkit可能会利用特定的端口及服务运行在系统之中，从而进行攻击。
通过分析开放端口列表以及运行在端口上的服务，我们便可以分析并检查恶意软件，保证主机安全。</p>
<p>了解及使用各种端口分析工具。</p>
<p>lsof - list open files
<code>lsof</code>列出系统中开放端口以及运行在端口上的服务的详细信息，文件被哪个程序使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">-a：列出打开文件存在的进程
-c&lt;进程名&gt;：列出指定进程所打开的文件
-g：列出GID号进程详情
-d&lt;文件号&gt;：列出占用该文件号的进程
+d&lt;目录&gt;：列出目录下被打开的文件
+D&lt;目录&gt;：递归列出目录下被打开的文件
-n&lt;目录&gt;：列出使用NFS的文件
-i&lt;条件&gt;：列出符合条件的进程（4、6、协议、:端口、 @ip ）
-p&lt;进程号&gt;：列出指定进程号所打开的文件
-u：列出UID号进程详情
-h：显示帮助信息
-v：显示版本信息


lsof /var/log/messages
COMMAND    PID USER   FD   TYPE DEVICE  SIZE/OFF     NODE NAME
rsyslogd <span class="m">12231</span> root    5w   REG  253,0 <span class="m">539973467</span> <span class="m">68539162</span> /var/log/messages
</code></pre></td></tr></table>
</div>
</div><p>netstat查看开放端口与服务
<code>netstat</code> - 显示网络连接，路由表，接口状态，伪装连接，网络链路信息和组播成员组;</p>
<p>iftop - display bandwidth usage on an interface by host
<code>iftop</code> - 展示带宽使用情况；</p>
<p>ifstat - handy utility to read network interface statistics
<code>ifstat</code> - 展示某时刻网络状态；</p>
<p>nload - displays the current network usage
<code>nload</code> - 可查看系统总带宽；</p>
<p>nethogs - Net top tool grouping bandwidth per process
<code>nethogs</code>- 可查看每个进程流量情况；
ethtool - query or control network driver and hardware settings
<code>ethtool</code> - 检查网卡支持的带宽</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#lsof的每一项都对应着一个打开了特定端口的服务</span>
lsof -i:port


<span class="c1">#查看开放端口和服务</span>
netstat -nltp


<span class="c1">#查看网络实时状态</span>
iftop


<span class="c1">#查看当前网络状态</span>
ifstat


<span class="c1">#查看系统带宽</span>
nload


<span class="c1">#查看进程流量</span>
nethogs
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h2 id="tcpdump">tcpdump</h2>
<p>tcpdump是一款嗅探工具，也就是命令行格式的wireshark。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">tcpdump - dump traffic on a network

tcpdump [options]
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">-a：尝试将网络和广播地址转换成名称；
-c&lt;数据包数目&gt;：收到指定的数据包数目后，就停止进行倾倒操作；
-d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出；
-dd：把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出；
-ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出；
-e：在每列倾倒资料上显示连接层级的文件头；
-f：用数字显示网际网络地址；
-F&lt;表达文件&gt;：指定内含表达方式的文件；
-i&lt;网络界面&gt;：使用指定的网络截面送出数据包；
-l：使用标准输出列的缓冲区；
-n：不把主机的网络地址转换成名字；
-N：不列出域名；
-O：不将数据包编码最佳化；
-p：不让网络界面进入混杂模式；
-q ：快速输出，仅列出少数的传输协议信息；
-r&lt;数据包文件&gt;：从指定的文件读取数据包数据；
-s&lt;数据包大小&gt;：设置每个数据包的大小；
-S：用绝对而非相对数值列出TCP关联数；
-t：在每列倾倒资料上不显示时间戳记；
-tt： 在每列倾倒资料上显示未经格式化的时间戳记；
-T&lt;数据包类型&gt;：强制将表达方式所指定的数据包转译成设置的数据包类型；
-v：详细显示指令执行过程；
-vv：更详细显示指令执行过程；
-x：用十六进制字码列出数据包资料；
-w&lt;数据包文件&gt;：把数据包数据写入指定的文件。
</code></pre></td></tr></table>
</div>
</div><br>
<p>栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#tcpdump默认将监视第一个网络接口上流过的数据包</span>
tcpdump


<span class="c1">#指定网络接口</span>
tcpdump -i eth1 -w /tmp/1.cap


<span class="c1">#指定主机</span>
tcpdump host <span class="nv">$hostname</span>
tcpdump host <span class="nv">$hostname1</span> and <span class="nv">$hostname2</span>


<span class="c1">#指定源和目标主机</span>
tcpdump -i eth0 src host <span class="nv">$hostname</span>
tcpdump -i eth0 dst host <span class="nv">$hostname</span>


<span class="c1">#指定主机和端口</span>
tcpdump tcp port <span class="m">22</span> host 192.168.1.11
tcpdump udp port <span class="m">53</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<hr>
<br/>
<h1 id="当个好管家">当个好管家</h1>
<h2 id="简介-7">简介</h2>
<p>操作系统(Operation System,OS)，是由一系列用于不同目的、服务于不同任务的系统软件组成。
日志记录(logging)和监视是很重要的，能帮助我们从大量数据中收集信息。</p>
<p>监视系统活动的各种命令，日志技术及其使用方法。</p>
<br>
<h2 id="统计磁盘使用情况dfdufdisk">统计磁盘使用情况(<code>df+du+fdisk</code>)</h2>
<p>磁盘空间是一种有限资源，我们需要了解磁盘的可用空间。</p>
<p><code>df</code>, <code>du</code>, <code>fdisk</code>是Linux中的磁盘管理三板斧
df(disk free): 报告文件系统磁盘空间的使用情况;
du(disk usage): 报告磁盘空间使用情况; 使用<code>du</code>时，要确保对其遍历的目录和文件拥有适合的读权限。
fdisk: Linux分区表操作工具软件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">du file1	<span class="c1">#默认以字节为单位</span>

<span class="c1">#-a,显示目录下所有文件大小</span>
du -a /home/zhang
du /home/zhang	<span class="c1">#只显示目录大小</span>


<span class="c1">#-h,以可读形式打印</span>
du -h /home/zhang


<span class="c1">#-c,显示使用总量</span>
du -c file1 /dir2
du -c *.txt *.sh


<span class="c1">#-s，打印摘要</span>
du -s /dir
du -sh /home/zhang


<span class="c1">#-b,-k,-m,-B，用特定单位打印</span>
du -k file1
du -m file2


<span class="c1">#--exclude,从磁盘统计中排除部分文件</span>
du --exclude<span class="o">=</span><span class="s2">&#34;*.swap&#34;</span> -sh /home/zhang


<span class="c1">#--max-depth,指定最大遍历深度</span>
du -h --max-depth n /dir
du -h --max-depth<span class="o">=</span><span class="m">2</span> /home/zhang


<span class="c1">#-x,将/mnt中所有挂载点排除在磁盘统计之外</span>
du -xh /dir


<span class="c1">#找出目录中最大的文件</span>
du -ak /dir <span class="p">|</span> sort -nrk <span class="m">1</span> <span class="p">|</span> head -n <span class="m">5</span>
<span class="c1">#此输出包含了目录大小，需要细化</span>
<span class="c1">#利用find替du过滤文件</span>
find /dir -type f --exec du -ak <span class="o">{}</span> <span class="se">\;</span> <span class="p">|</span> sort -nrk <span class="m">1</span> <span class="p">|</span> head


<span class="c1">#df,磁盘可用空间信息</span>
df -h
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="计算命令执行时间">计算命令执行时间</h2>
<p>当测试一个应用程序或比较不同的算法时，程序的执行时间非常重要。所以需要计算命令执行时间。</p>
<p>所有的Unix-Like操作系统都包含time命令，可将time放在需要计算执行时间的命令前。</p>
<blockquote>
<p>time命令有个可执行二进制文件位于/usr/bin/time，还有一个shell built-in命令也叫作time；
当运行time时，默认调用的是shell built-in命令。內建time命令选项有限；
因此，如果我们需要使用另外的功能，就应该使用/usr/bin/time命令。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#计算命令执行时间</span>
<span class="nb">time</span> <span class="nb">command</span>
<span class="nb">time</span> ls


<span class="c1">#real,挂钟时间(wall clock time),命令从开始执行到结束的时间；</span>
<span class="c1">#user,指进程花费在用户模式(user-mode)中的CPU时间。这是唯一用于执行进程所花费的时间；</span>
<span class="c1">#sys，指进程花费在内核模式(in the kernel)中的CPU时间。它代表在内核中执行系统调用所使用的时间。</span>


<span class="c1">#-o,将命令执行时间写入文件</span>
/usr/bin/time -o exetime.txt ls /

<span class="c1">#-a,不影响原文件</span>
/usr/bin/time -a -o exetime.txt ls /home

<span class="c1">#-f,格式化时间输出</span>
<span class="c1">#时间格式字符串</span>
<span class="c1">#real	%e</span>
<span class="c1">#user	%U</span>
<span class="c1">#sys	%S</span>
/usr/bin/time -f <span class="s2">&#34;FORMAT STRING&#34;</span> <span class="nb">command</span>
/usr/bin/time -f <span class="s2">&#34;Rtme: %e&#34;</span> -a -o timing.log uname
/usr/bin/time -f <span class="s2">&#34;Rtime: %e\nUtime: %U\nStime: %S&#34;</span> -ao timing.log uname
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="当前登录用户启动日志启动故障的相关信息wwholastblast">当前登录用户、启动日志、启动故障的相关信息(<code>w+who+lastb+last</code>)</h2>
<p>收集与操作系统、当前登录用户、主机运行时间、启动故障等相关信息很有用处。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#获取当前登录用户</span>
who	<span class="c1">#显示已经登录的用户</span>
w	<span class="c1">#显示已经登录的用户以及他们在做什么</span>
<span class="c1">#会显示用户使用的伪终端(pseudo TTY)，对应设备文件出现在/dev/pts/n</span>

<span class="c1">#列出登录主机的用户列表</span>
users

<span class="c1">#查看系统运行时间</span>
uptime

<span class="c1">#显示用户登录列表</span>
last
<span class="c1">#获取某个用户登录信息</span>
last zhang
<span class="c1">#获取重启会话信息</span>
last reboot

<span class="c1">#获取失败的用户登录信息</span>
lastb
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="打印10条最常使用的命令history">打印10条最常使用的命令(<code>history</code>)</h2>
<p>终端是用来访问shell的工具，在shell中我们可以输入并执行命令。我们可以找出在shell中运行最多的命令。</p>
<p>~/.bash_history，默认保留1000个最近执行命令。或者<code>history</code>命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">cat .bash_history <span class="p">|</span> sort -n <span class="p">|</span> uniq -c <span class="p">|</span> sorn -nr <span class="p">|</span> head
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="列出占用cpu最多的进程">列出占用CPU最多的进程</h2>
<p>CPU时间是一项重要资源，有时需要跟踪占用CPU周期最多的进程。
对于需要处理大量请求的服务器来说，CPU是极其重要的资源。通过监视某个时期内CPU的使用情况，可以找出长期占用CPU的进程并对其进行优化，或是调试其他问题。</p>
<p>用<code>ps</code>命令收集系统中进程的详细信息。
ps - report a snapshot of the current processes</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#-e,以标准语法显示每个进程</span>
ps -e
ps -ef


<span class="c1">#ax,以BSD语法显示每个进程</span>
ps ax
pa axu


<span class="c1">#获取安全信息</span>
<span class="c1">#ps -eo euser,ruser,suser,fuser,f,comm,pcpu,label</span>


<span class="c1">#comm显示命令，pcpu显示CPU使用率</span>
ps -eo comm,pcpu


<span class="c1">#监视并计算一小时内CPU使用情况的shell脚本</span>
<span class="nv">secs</span><span class="o">=</span><span class="m">3600</span>
<span class="nv">unit_time</span><span class="o">=</span><span class="m">60</span>
<span class="nv">steps</span><span class="o">=</span><span class="k">$((</span><span class="nv">$secs</span> <span class="o">/</span> <span class="nv">$unit_time</span><span class="k">))</span>

<span class="nb">echo</span> <span class="s2">&#34;Whatching CPU usage...&#34;</span>

<span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span>0<span class="p">;</span> i&lt;steps<span class="p">;</span> i++<span class="o">))</span>
<span class="k">do</span>
	ps -eo comm,pcpu <span class="p">|</span> tail -n +2 &gt;&gt; /tmp/cpu_usage.<span class="nv">$$</span>
    sleep <span class="nv">$unit_time</span>
<span class="k">done</span>

<span class="nb">echo</span> <span class="s2">&#34;CPU eaters: &#34;</span>

cat /tmp/cpu_usage.<span class="nv">$$</span> <span class="p">|</span> <span class="se">\
</span><span class="se"></span>awk <span class="s1">&#39;{process[$1]+=$2}
</span><span class="s1">END{
</span><span class="s1">	for (i in process) {
</span><span class="s1">    	printf(&#34;%-20s %s&#34;,i,process[i]);
</span><span class="s1">    }
</span><span class="s1">}&#39;</span> <span class="p">|</span> sort -nrk <span class="m">2</span> <span class="p">|</span> head

<span class="c1">#tail -n +K，从第K行开始输出。上面输出第一行是 COMAND 和 %CPU</span>

<span class="c1">#$1,command; $2,%CPU</span>
<span class="c1">#process[$1]是一个关联函数，相当于arr[command]</span>
<span class="c1">#arr[command]=arr[command]+ $2，计算同一命令的累积时间</span>
<span class="c1">#i指命令，process[i]指命令运行时间</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="用watch监视命令输出">用<code>watch</code>监视命令输出</h2>
<p>可能需要在在某段时期内以固定的间隔时间不短监视某个命令的输出。可利用<code>watch</code>命令。</p>
<p>watch - execute a program periodically, showing output fullscreen</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#watch命令可以用来在终端以固定的间隔监视命令输出，默认2秒间隔</span>
watch <span class="nb">command</span>
watch <span class="s1">&#39;command&#39;</span>


watch ls
watch <span class="s1">&#39;ls -l&#39;</span>


<span class="c1">#-n,指定时间间隔</span>
watch -n <span class="m">5</span> <span class="s1">&#39;yum update -y&#39;</span>


<span class="c1">#-d，突出(highlighting)watch输出中的差异</span>
watch -d -n 1<span class="s1">&#39;dd if=/dev/zero of=/tmp/zero.test&#39;</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="对文件及目录访问进行记录inotifywait">对文件及目录访问进行记录(<code>inotifywait</code>)</h2>
<p>记录重要文件及目录访问，对于追踪文件和目录的变化很有帮助。
<code>inotifywait</code>命令可以用来收集有关文件访问的信息。
<code>inotifywait</code>和<code>rsync</code>用户实时同步哦！</p>
<p>inotifywait - wait for changes to files using inotify</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">yum install -y inotify-tools

<span class="c1">#-q,减少冗余信息</span>
inotifywait -m -r -q -e create,move,delete /dir
inotifywait -m -r -q -e create,move,modify,delete /home/zhang &gt;&gt; inotifywait.log

<span class="c1">#利用inotifywait检测，rsync同步</span>
inotifywait -mrq -e create,move,modify,delete /dir --exclude<span class="o">=</span><span class="s2">&#34;*.swap&#34;</span> <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> file
<span class="k">do</span>
rsync -av --exclude<span class="o">=</span><span class="s2">&#34;*.swqp&#34;</span> --delete /dir user@host:PATH &gt; /dev/null 2&gt;<span class="p">&amp;</span><span class="m">1</span>
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="用logrotate管理日志文件">用<code>logrotate</code>管理日志文件</h2>
<p>日志文件是Linux系统维护中必不可少的组成部分。日志文件可以帮助跟踪系统中多种服务所发生的事件，这有助于排除系统问题。
但随着时间推移，日志文件会变得越来越大。因而必须对日志文件进行管理。</p>
<p>我们可以利用一种称为“轮询(rotation)”的技术来限制日志文件的体积。一旦日志文件超过了限定大小，就要对它的内容进行抽取(strip)，同时将日志文件的旧条目归档到文件中。</p>
<p><code>logratate</code>是每一位Linux系统管理员都应该了解的命令。它能够将日志文件大大小限制在给定的SIZE内。
logrotate配置文件位于<code>/etc/logrotate.d</code></p>
<p>logrotate ‐ rotates, compresses, and mails system logs</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">vim /etc/logrotated.d/custom

/var/log/custom.log <span class="o">{</span>
	missingok	<span class="c1">#日志文件丢失，则忽略</span>
    notifempty	<span class="c1">#仅当源日志文件非空时才进行轮替</span>
    size 30k	<span class="c1">#限制实施轮替的日志文件大小</span>
    compress	<span class="c1">#压缩旧日志</span>
    weekly	<span class="c1">#轮询时间，daily,weekly,yearly</span>
    rotate 7	<span class="c1">#保留旧日志数量</span>
    create <span class="m">0600</span> root root	<span class="c1">#创建的日志文件模式，用户和用户组</span>
<span class="c1">#还有一些其他选项</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="用sys记录日志">用sys记录日志</h2>
<p>在Linux系统中，在/var/log中创建并写入日志信息的是由被称为syslog的协议处理的。它由守护进程syslogd负责执行。
每一个标准应用进程都可以用syslog记录日志信息。</p>
<p>syslog处理/var/log下的多个日志文件。但是当logger发送消息时，它用标记字符串来确定应该纪录到哪一个日志文件中。
syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。
可以从<code>/etc/rsyslog.d/</code>目录的配置文件中看到与日志文件相关联的标记字符串。</p>
<p>Linux中一些重要日志文件：</p>
<blockquote>
<p>/var/log/boot.log， 系统启动信息；
/var/log/message， 内核启动信息；
/var/log/auth.log， 用户认证日志；
/var/log/dmesg， 系统启动信息；
/var/log/mail.log， 邮件服务器日志。</p>
</blockquote>
<p>logger - a shell command interface to the syslog</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#logger命令，默认记录日志信息到/var/log/messages</span>
logger <span class="s2">&#34;test log message to messages&#34;</span>
tail -n <span class="m">1</span> /var/log/message

<span class="c1">#-t，指定特定TAG</span>
logger -t TAG <span class="s2">&#34;test log message to messages&#34;</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h1 id="管理重任">管理重任</h1>
<h2 id="简介-8">简介</h2>
<p>GNU/Linux的生态系统是由运行的程序、服务、连接的设备、文件系统、用户等组成。按照我们需要的方式对整个系统有一个微观并对操作系统进行整体上的管理，这就是系统管理的主要目的。</p>
<h2 id="收集进程信息toppspgrep">收集进程信息(<code>top+ps+pgrep</code>)</h2>
<p>进程是程序运行实例(runing instance)。
同一程序的多个实例可以同时运行，但他们的进程ID却互不相同。</p>
<p>进程管理相关的重要命令是：</p>
<ul>
<li><code>top</code>, display Linux processes;</li>
<li><code>ps</code>, report a snapshot of the current processes;</li>
<li><code>pgrep</code>, look up or signal processes based on name and other attributes.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#ps命令</span>
<span class="c1">#-f, 显示更多进程信息</span>
ps -f

<span class="c1">#-e,every; -a,all</span>
ps -ef
ps -ax

<span class="c1">#-o, 指定想要的列</span>
ps -e -o parameter1,parameter2...
ps -eo comm,pcpu,pmem


<span class="c1">#pccpu	CPU占用率</span>
<span class="c1">#pid	进程ID</span>
<span class="c1">#ppid	父进程ID</span>
<span class="c1">#pmem	内存使用率</span>
<span class="c1">#comm	命令名</span>
<span class="c1">#cmd	简单命令</span>
<span class="c1">#user	启动进程的用户</span>
<span class="c1">#nice	优先级</span>
<span class="c1">#time	累积的CPU时间</span>
<span class="c1">#etime	进程启动后度过的时间</span>
<span class="c1">#tty	所关联的TTY设备</span>
<span class="c1">#euid	有效用户ID</span>
<span class="c1">#stat	进程状态</span>


<span class="c1">#--sort,根据参数对ps输出进行排序</span>
<span class="c1">#+升序，-降序</span>
ps -eo comm,pcpu,pmem --sort -pcpu
ps -eo comm,pcpu,pmem --sort -pcpu,+pmem


<span class="c1">#-C, 给定命令全名找出PID</span>
ps -C cmd -o comm,pid


<span class="c1">#-u, 指定有效用户列表</span>
<span class="c1">#-U, 指定真实用户列表</span>
ps -u root -U zhang -o user,pcpu


<span class="c1">#-t, 用TTY过滤输出</span>
ps -t TTY1,TTY2...
ps -t pts/0,pts/1 -ef


<span class="c1">#-L, 显示进程相关信息</span>
<span class="c1">#LWP线程ID， NLWP线程数量</span>
ps -efL


<span class="c1">#pgrep命令, 获得一个特定命令的PID列表</span>
<span class="c1">#它只需要命令的一部分即可</span>
pgrep cmd
pgre inotif
pgrep bas

<span class="c1">#-d, 指定定界符</span>
pgrep rsync -d <span class="s2">&#34;:&#34;</span>

<span class="c1">#-u, 指定进程的用户</span>
pgrep -u root,zhang rsync

<span class="c1">#-c, 返回匹配的进程数量</span>
pgrep -c rsync


<span class="c1">#top命令</span>
top
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<h2 id="杀死进程以及发送响应信息killkillalltrap">杀死进程以及发送响应信息(<code>kill+killall+trap</code>)</h2>
<p>在Unix-Like环境中与进程有关的一个重要概念就是信号。
信号是一种进程间通信机制，它用来中断运行的进程以执行某些操作。终止程序也是通过使用信号技术来实现的。</p>
<p>像<code>ctrl+C</code>,<code>ctrl+Z</code>这种作业都属于信号。</p>
<ul>
<li><code>kill</code> 命令可用来向进程发送信号;</li>
<li><code>trap</code> 命令用来处理所接收的信号;</li>
<li><code>killall</code> 以名字方式来杀死进程.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#列出所有可用信号</span>
<span class="nb">kill</span> -l


<span class="c1">#-s, 发送信号</span>
<span class="c1">#信号名称和信号数都可以</span>
<span class="nb">kill</span> -信号数 PID
<span class="nb">kill</span> -s SIGNAL PID


<span class="c1">#常用信号</span>
<span class="c1">#SIGHUP   1    终端断线(对控制进程或终端进行挂起检测(hangup detection))</span>
<span class="c1">#SIGINT   2    中断(当按下Ctrl+C时发送该信号)</span>
<span class="c1">#SIGQUIT  3    退出(同Ctrl+\)</span>
<span class="c1">#SIGKILL  9    强制终止(强行杀死进程)</span>
<span class="c1">#SIGTERM  15   终止进程</span>
<span class="c1">#SIGCONT  18   继续(与STOP相反，fg/bg命令)</span>
<span class="c1">#SIGTST0P 19   暂停(当按下crtl+z时发送该信号)</span>


<span class="c1">#killall, 通过命令名终止进程</span>
killall -s SIGNAL PName
killall -信号数 PName


<span class="c1">#trap, 捕捉并响应信号</span>
<span class="nb">trap</span> <span class="s1">&#39;signal-handler-func&#39;</span> SIGNAL LIST
</code></pre></td></tr></table>
</div>
</div><br>
<p><strong>kill信号详解</strong>
参考: <a href="https://www.imooc.com/article/48534">https://www.imooc.com/article/48534</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
</code></pre></td></tr></table>
</div>
</div><p>Linux信号列表：</p>
<ul>
<li><code>SIGHUP 1</code>:  A 终端挂起或者控制进程终止</li>
<li><code>SIGINT 2</code>:  A 键盘中断（如break键被按下）</li>
<li><code>SIGQUIT 3</code>:  C 键盘的退出键被按下</li>
<li><code>SIGILL 4</code>:  C 非法指令</li>
<li><code>SIGABRT 6</code>:  C 由abort(3)发出的退出指令</li>
<li><code>SIGFPE 8</code>:  C 浮点异常</li>
<li><code>SIGKILL 9</code>:  AEF Kill信号</li>
<li><code>SIGSEGV 11</code>:  C 无效的内存引用</li>
<li><code>SIGPIPE 13</code>:  A 管道破裂: 写一个没有读端口的管道</li>
<li><code>SIGALRM 14</code>:  A 由alarm(2)发出的信号</li>
<li><code>SIGTERM 15</code>:  A 终止信号</li>
<li><code>SIGUSR1 30,10,16</code>:  A 用户自定义信号1</li>
<li><code>SIGUSR2 31,12,17</code>:  A 用户自定义信号2</li>
<li><code>SIGCHLD 20,17,18</code>:  B 子进程结束信号</li>
<li><code>SIGCONT 19,18,25</code>:  进程继续（曾被停止的进程）</li>
<li><code>SIGSTOP 17,19,23</code>:  DEF 终止进程</li>
<li><code>SIGTSTP 18,20,24</code>:  D 控制终端（tty）上按下停止键</li>
<li><code>SIGTTIN 21,21,26</code>:  D 后台进程企图从控制终端读</li>
<li><code>SIGTTOU 22,22,27</code>:  D 后台进程企图从控制终端写</li>
</ul>
<p>处理动作中的字母含义：</p>
<ul>
<li><code>A</code>: 缺省的动作是终止进程</li>
<li><code>B</code>: 缺省的动作是忽略此信号，将该信号丢弃，不做处理</li>
<li><code>C</code>: 缺省的动作是终止进程并进行内核映像转储（dump core），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员 提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。</li>
<li><code>D</code>: 缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）</li>
<li><code>E</code>: 信号不能被捕获</li>
<li><code>F</code>: 信号不能被忽略</li>
</ul>
<br/>
<br/>
<h2 id="which-whereis-file-whatis与平均负载"><code>which</code>, <code>whereis</code>, <code>file</code>, <code>whatis</code>与平均负载</h2>
<p><code>which</code> hows the full path of (shell) commands。找出某个命令的位置;
<code>whereis</code> locate the binary, source, and manual page files for a command。不仅返回命令路径，还能打印命令手册的位置以及命令源代码路径;
<code>file</code> determine file type。用来确定文件类型;
<code>whatis</code> display manual page descriptions。输出简短描述信息;
平均负载(load average),是系统运行总负载量的一个重要参数。它指明了系统中可运行进程总量的平均值。平均负载由三个值来指定，第一个指明1分钟内的平均值，第二个指明5分钟内的平均值，第三个指明15分钟内的平均值。</p>
<ul>
<li>单核CPU，类似于单车道，负载在 0.00-1.00 之间正常；</li>
<li>多核CPU，类似于多车道，负载在 核数*(0.00-1.00) 之间正常；</li>
<li>安全的系统负载，单核应该在 0.7 以下；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#查看平均负载</span>
uptime
cat /proc/loadavg
<span class="c1">#0.00 0.01 0.05 1/355 44955</span>
<span class="c1">#分母355表示系统进程总数, 分子表示正在运行的进程数, 最后一个数字表示最近运行进程ID</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="向用户终端发送消息">向用户终端发送消息</h2>
<p>系统管理员可能需要向网络中所有主机上的所有用户或特定用户的终端发送消息。
`wallrsync -av &ndash;exclude=&quot;*.s命令用来向所有当前登录用户的终端写入消息。</p>
<p>在Linux系统中，终端是作为设备存在的。因此那些打开的终端在<code>dev/pts/</code>中都会与对应的设备节点文件。向特定设备写入数据将会在对应的终端显示出消息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">echo</span> <span class="s2">&#34;It&#39;s just a test&#34;</span> <span class="p">|</span> wall

<span class="c1">#查看用户对应的/dev/pts/, 并向某一个用户终端发送信息</span>
ll /dev/pts <span class="p">|</span> awk <span class="s1">&#39;{print $3,$6}&#39;</span>
echo<span class="s2">&#34;Haha&#34;</span> &gt; /dev/pts/<span class="o">[</span>1,2,3...<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><br/>
<h2 id="收集系统信息">收集系统信息</h2>
<p>包括主机名、内核版本、Linux发行版本、CPU信息、内存信息、磁盘分区信息等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#主机名</span>
hostname
uname -n

<span class="c1">#内核版本，架构</span>
uname -r
uname -m
uname -a

<span class="c1">#Linux发行版本</span>
cat /etc/redhat-release

<span class="c1">#CPU相关信息</span>
lscpu
cat /proc/cpuinfo
cat /proc/cpuinfo <span class="p">|</span> grep <span class="s1">&#39;model name&#39;</span>

<span class="c1">#内存详细信息</span>
free -h
cat /proc/meminfo

<span class="c1">#分区信息</span>
cat /proc/partitions
fdisk -l

<span class="c1">#系统详细信息</span>
lshw
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="用proc收集信息">用/proc收集信息</h2>
<p>在GNU/Linux操作系统中，/proc是一个位于内存中的伪文件系统(in-memory pseudo filesystem)。
它的引用是为了提供一个可以从用户空间(user space)读取系统参数的接口。</p>
<p>可以对<code>/proc</code>中的文件和子目录进行<code>cat</code>来获取信息，所有内容都是易读的格式化文本。</p>
<blockquote>
<p>/proc/下的数字目录，包含了对应进程的相关信息；
/proc/environ，包含于进程相关联的环境变量；
/proc/cwd，是一个到进程工作目录的符号链接；
/proc/fbcat，包含了由进程所使用的文件描述符。</p>
</blockquote>
<br/>
<h2 id="用cron进行调度">用cron进行调度</h2>
<p>GNU/Linux系统包含了各种用于调度任务的工具。cron就是其中之一，它通过守护进程crond使得任务能够以固定的时间间隔在系统后台自动运行。
cron利用的是一个被称为“cron表(cron table)”的文件，这个文件中存储了需要执行的脚本或命令的调度列表以及执行时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#分 时 日 月 周</span>
<span class="c1">#*  *  *  *  *  cmd</span>
<span class="c1">#分钟(0-59)</span>
<span class="c1">#小时(0-23)</span>
<span class="c1">#天(1-31)</span>
<span class="c1">#月(1-12)</span>
<span class="c1">#工作日(0-7)，0和7都代表周天</span>
<span class="c1">#命令</span>

<span class="c1">#*号,所有值</span>
<span class="c1">#,号,范围。1,3,5,7,9</span>
<span class="c1">#-号,连续范文。1-10</span>
<span class="c1">#/号,*/10;0-8/20</span>



<span class="c1">#栗子</span>
crontab -e

* 0-6 * * * /home/zhang/test.sh
1,3,5,7,9 * * * * /home/zhang/test.sh
*/5 * * * * /home/zhang/test.sh

<span class="c1">#-l,查看cron表</span>
crontab -l

<span class="c1">#-r,移除cron表</span>
crontab -r
</code></pre></td></tr></table>
</div>
</div><h3 id="cron的高级写法"><code>cron</code>的高级写法</h3>
<p>栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">@reboot  <span class="c1">#在启动的时候运行一次</span>
<span class="c1">#其实@reboot类似于rc.local，开机启动</span>

@yearly <span class="o">==</span> @annually <span class="o">==</span> <span class="m">0</span> <span class="m">0</span> <span class="m">1</span> <span class="m">1</span> *  <span class="c1">#一年一次</span>

@monthly <span class="o">==</span> <span class="m">0</span> <span class="m">0</span> <span class="m">1</span> * *  <span class="c1">#每月一次</span>

@weekly  <span class="o">==</span> <span class="m">0</span> <span class="m">0</span> * * <span class="m">0</span>  <span class="c1">#每周一次</span>

@daily <span class="o">==</span> @midnight <span class="o">==</span> <span class="m">0</span> <span class="m">0</span> * * *  <span class="c1">#每天一次</span>

@hourly <span class="o">==</span> <span class="m">0</span> * * * *  <span class="c1">#每小时一次</span>


crontab -e
@reboot /bin/mongod -f /etc/mongod_27018.conf

vim /etc/rc.d/rc.local
/bin/mongod -f /etc/mongod_27018.conf
chmod a+x /etc/rc.d/rc.local
</code></pre></td></tr></table>
</div>
</div><br>
<h2 id="用户管理常用命令">用户管理常用命令</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#添加用户</span>
useradd


<span class="c1">#删除用户</span>
userdel
--remove-all-file删除与用户相关的所有文件


<span class="c1">#修改shell</span>
chsh


<span class="c1">#修改用户属性</span>
usermod


<span class="c1">#修改密码过期时间</span>
chage


<span class="c1">#修改密码</span>
passwd


<span class="c1">#登录到一个新组</span>
newgrp


<span class="c1">#添加、删除组</span>
groupadd
groupdel


<span class="c1">#指纹</span>
finger
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<hr>
<br/>
<h1 id="iptables和firewalld">iptables和firewalld</h1>
<p>**firewalld与iptables比较: **</p>
<ul>
<li>iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已。或者说，它们只是一种服务</li>
<li>firewalld可以动态修改单条规则，动态管理规则集，允许更新规则而不破坏现有会话和连接；iptables在修改了规则后必须得全部刷新才可以生效</li>
<li>firewalld使用区域和服务而不是链式规则</li>
<li>firewalld默认是拒绝的，需要设置以后才能放行；iptables默认是允许，需要拒绝的才去限制</li>
<li>firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现。真正使用规则干活的是内核的netfilter</li>
<li>firewalld是iptables的一个封装，可以让你更容易地管理iptables规则。它并不是iptables的替代品</li>
<li>firewalld拥有CLI和GUI的两种管理方式</li>
</ul>
<br/>
<br/>
<h2 id="firewalld">firewalld</h2>
<h3 id="区域管理">区域管理</h3>
<p>通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同程序区域间传送数据流。
firewalld的默认区域是public区域。</p>
<p>九大区域：</p>
<ul>
<li>
<p>阻塞区域（block）
任何传入的网络数据包都将被阻止</p>
</li>
<li>
<p>工作区域（work）
相信网络上的其他计算机，不会损害你的计算机</p>
</li>
<li>
<p>家庭区域（home）
相信网络上的其他计算机，不会损害你的计算机</p>
</li>
<li>
<p>公共区域（public）
不相信网络上的任何计算机，只有选择接受传入的网络连接</p>
</li>
<li>
<p>隔离区域（DMZ）
隔离区域也称为非军事区域，内外网络之间增加的一层网络，起到缓冲作用。对于隔离区域，只有选择接受传入的网络连接</p>
</li>
<li>
<p>信任区域（trusted）
所有的网络连接都可以接受</p>
</li>
<li>
<p>丢弃区域（drop）
任何传入的网络连接都被拒绝</p>
</li>
<li>
<p>内部区域（internal）
信任网络上的其他计算机，不会损害你的计算机。只有选择接受传入的网络连接</p>
</li>
<li>
<p>外部区域（external）
不相信网络上的其他计算机，不会损害你的计算机。只有选择接受传入的网络连接</p>
</li>
</ul>
<p>firewalld有三种配置方法：</p>
<ul>
<li>firewll-config(GUI)</li>
<li>firewall-cmd(CLI)</li>
<li>编辑XML配置文件</li>
</ul>
<br>
<p>firewalld默认提供了九个区域的配置文件，它们位于<code>/usr/lib/firewalld/zones</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ls /usr/lib/firewalld/zones

block.xml  dmz.xml  drop.xml  external.xml  home.xml  internal.xml  public.xml  trusted.xml  work.xml
</code></pre></td></tr></table>
</div>
</div><p>常用命令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">yum  install  firewalld  firewall-config
systemctl start firewalld
firewall-cmd --version
firewall-cmd --help

#永久生效需加上 --permannent
firewall-cmd xxx --permannent


firewall-cmd --state


#查看网络接口使用的区域
firewall-cmd --get-active-zones


#查看指定区域的所有配置
firewall-cmd --zone=public --list-all


#查看所有区域配置
firewall-cmd --list-all-zones


#查看默认区域
firewall-cmd --get-default-zone


#设置默认区域
firewall-cmd --set-default-zone=internal


#查看指定接口所属区域
firewall-cmd --get-zone-of-interface=eth0


#将接口添加到区域，默认接口都在public
firewall-cmd --zone=public --add-interface=eth0


#拒绝|开启 所有包
firewall-cmd --panic-on|off


#查看是否拒绝
firewall-cmd --query-panic


#无需断开连接更新防火墙规则
firewall-cmd --reload


#类似于重启更新规则
firewall-cmd --complete-reload


#查看所有打开的端口
firewall-cmd --zone=dmz --list-ports


#加入一个端口的区域
firewall-cmd --zone=dmz --add-port=8080/tcp

</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<h3 id="与服务一起使用">与服务一起使用</h3>
<p>firewalld可以根据特定网络服务的预定义规则来允许相关流量。你可以自定义系统规则，并将它们添加到任何区域。</p>
<ul>
<li>默认支持的服务的配置文件位置: <code>/usr/lib/firewalld/services</code></li>
<li>创建的服务文件位置: <code>/etc/firewalld/services</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">cat /usr/lib/firewalld/service/elasticsearch.xml

&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;service&gt;
  &lt;short&gt;Elasticsearch&lt;/short&gt;
  &lt;description&gt;Elasticsearch is a distributed, open source search and analytics engine, designed for horizontal scalability, reliability, and easy management.&lt;/description&gt;
  &lt;port protocol=&#34;tcp&#34; port=&#34;9300&#34;/&gt;
  &lt;port protocol=&#34;tcp&#34; port=&#34;9200&#34;/&gt;
&lt;/service&gt;
</code></pre></td></tr></table>
</div>
</div><p>常用命令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#查看默认可用服务
firewall-cmd --get-services


#永久启用或禁用HTTP服务
firewall-cmd --zone=区域 --(add|remove)-service=http --permanent


#添加123456端口的tcp流量
firewall-cmd --zone=public --add-port=123456/tcp --permanent


#将80端口的流量转发到123456端口
firewall-cmd --zone=public --add-forward-port=port=80:proto=tcp:toport=123456
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h2 id="iptables">iptables</h2>
<p>iptables/ip6tables — administration tool for IPv4/IPv6 packet filtering and NAT</p>
<p>切记谨慎使用iptables命令，特别是在远程连接的时候。
规则是有顺序的，规则的顺序很重要。当规则顺序排列错误时，会产生很严重的错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">iptables --help

-t&lt;表&gt;： 指定要操纵的表，默认为filter

-P： 设置默认策略

-A &lt;链&gt;： 在规则链的末尾中添加条目
-I &lt;链&gt;： 在规则链的头部中插入条目
#请注意-A与-I，这两者的插入顺序是不一致的，-I顺序更高
-D &lt;链&gt;： 从规则链中删除条目
-R： 替换规则链中的条目

-L： 显示规则链中已有的条目
-F： 清楚规则链中已有的条目
-Z： 清空规则链中的数据包计算器和字节计数器
-X： 删除用户定义的链
-N： 创建新的用户自定义规则链

-p： 指定要匹配的数据包协议类型(tcp, udp, icmp...)

-s： 指定要匹配的数据包源ip地址(ip/mask, !ip)
-d： 匹配 目标地址
--sport： 匹配源端口号
--dport： 匹配目的端口号

-i&lt;网络接口&gt;： 指定数据包进入本机的网络接口
-o&lt;网络接口&gt;： 指定数据包要离开本机所使用的网络接口

-j target： 指定要跳转的目标
-m match： 扩展匹配
-g chain： jump to chain with no return
</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<h3 id="表格链动作">表格/链/动作</h3>
<p>为什么称为iptables? 因为此软件里面有多个表格(table)，每个表格定义了自己的默认策略和规则，且每个表格的用途都不相同。</p>
<p><strong>表(Table)</strong></p>
<ul>
<li>
<p>raw: 高级功能</p>
</li>
<li>
<p>mangle: 数据包修改</p>
</li>
<li>
<p>nat: 网络地址转换</p>
<ul>
<li>PREROUTING</li>
<li>POSTROUTING</li>
<li>OUTPUT</li>
</ul>
</li>
<li>
<p>filter: 包过滤，是默认表</p>
<ul>
<li>INPUT</li>
<li>OUTPUT</li>
<li>FORWARD</li>
</ul>
</li>
</ul>
<br>
<p><strong>链(Chain)</strong></p>
<ul>
<li>INPUT：处理输入数据包</li>
<li>OUTPUT：处理输出数据包</li>
<li>FORWARD：处理转发数据包</li>
<li>PREROUTING：用于目标地址转换(DNAT)</li>
<li>POSTOUTING：用于源地址转换(SNAT)</li>
</ul>
<br>
<p><strong>动作(Action)</strong></p>
<ul>
<li>ACCEPT： 接收数据包</li>
<li>DROP： 丢弃数据包</li>
<li>REJECT: 拒绝</li>
<li>REDIRECT： 重定向、映射、透明代理</li>
<li>SNAT： 源地址转换</li>
<li>DNAT： 目标地址转换</li>
<li>MASQUERADE： IP伪装（NAT），用于ADSL</li>
<li>LOG： 日志记录</li>
</ul>
<br>
<br/>
<h3 id="常用命令">常用命令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#格式</span>
iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 <span class="o">[</span>规则号<span class="o">]</span> &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作



-A: 新增一条规则，在最后面
-I: 插入一条规则，如果没有指定顺序，默认变成第一条规则
--line-numbers： 显示规则行号


-i: 包所进入的那个网络接口
-o: 包所传出的那个网络接口


-p: 指定网络协议
-p tcp --syn<span class="o">(</span>ack, rst<span class="o">)</span>
-p udp
-p icmp
-p all

-s: 源IP或网段
-d: 目标IP或网段
-s 192.168.1.11
-d 192.168.1.0/24<span class="o">(</span>192.168.1.0/255.255.255.0<span class="o">)</span>
-s !192.168.2.0/24


-j: 后接动作


<span class="c1">#记录，此日志默认追加到messages</span>
-j LOG --log-prefix<span class="o">=</span>‘IPTABLES-’




<span class="c1">#端口号可以是连续的</span>
--sport 1026:65535
--dport <span class="m">80</span>


-m: 一些iptables外部模块
-m state: 状态模块
-m mac: 网卡地址


--state: 数据包状态
--state INVALID： 无效的数据包
--state ESTABLISHED: 已建立连接
--state NEW: 想要新建连接的数据包
--state RELATED: 表示这个数据包是我们主机发送出去的


--mac-source: 源主机的硬件地址
</code></pre></td></tr></table>
</div>
</div><br>
<p><strong>清除防火墙规则:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">iptables  <span class="o">[</span> -t  tables <span class="o">]</span>  <span class="o">[</span> -FXZ <span class="o">]</span>

<span class="c1">#清除所有已制定的规则</span>
iptables -F

<span class="c1">#清除用户 &#34;自定义&#34;</span>
iptables -X

<span class="c1">#将所有链表的计数与流量统计都归零</span>
iptables -Z


<span class="c1">#这三个命令会将本机防火墙的所有规则都清除，但却不会改变 默认策略</span>
</code></pre></td></tr></table>
</div>
</div><br>
<p><strong>定义默认策略</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">--policy, -P

iptables -P INPUT DROP
iptables -P OUTPUT ACCESS
iptables -P FORWARD ACCEPT
</code></pre></td></tr></table>
</div>
</div><br>
<p><strong>开放某个端口</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#允许本地回环接口(即运行本机访问本机)</span>
iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT

<span class="c1">#允许已建立的或相关连的通行</span>
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

<span class="c1">#针对网卡执行的放行和防御</span>
iptables  -A  INPUT  -m  mac  --mac--source  aa:bb:cc:11:22:33  -j  DROP

<span class="c1">#允许所有本机向外的访问</span>
iptables -A OUTPUT -j ACCEPT

<span class="c1">#允许访问22端口</span>
iptables -A INPUT -p tcp --dport <span class="m">22</span> -j ACCEPT

<span class="c1">#允许访问80端口</span>
iptables -A INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># #禁止其他未允许的规则访问</span>
iptables -A INPUT -j reject

<span class="c1">#禁止其他未允许的规则访问</span>
iptables -A FORWARD -j REJECT

</code></pre></td></tr></table>
</div>
</div><br>
<p><strong>屏蔽IP</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#屏蔽单个IP的命令</span>
iptables -I INPUT -s 123.45.6.7 -j DROP

<span class="c1">#封整个段即从123.0.0.1到123.255.255.254的命令</span>
iptables -I INPUT -s 123.0.0.0/8 -j DROP

</code></pre></td></tr></table>
</div>
</div><br>
<p><strong>查看规则</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#推荐使用iptables-save</span>
iptables-save

<span class="c1">#备份和恢复</span>
iptables-save &gt;/etc/sysconfig/iptables
iptables-restore &lt;/etc/sysconfig/iptables


iptables  -L  -n
iptables -L -n --line-numbers
</code></pre></td></tr></table>
</div>
</div><br>
<p><strong>删除已添加规则</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">iptables -L -n --line-numbers

iptables -D INPUT <span class="m">5</span>
iptables -D OUTPUT <span class="m">3</span>
</code></pre></td></tr></table>
</div>
</div><br>
<br/>
<h3 id="解决重启失效">解决重启失效</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">iptables-save &gt;/etc/sysconfig/iptables

<span class="c1">#把此加入开机启动</span>
iptables-restore &lt;/etc/sysconfig/iptables

</code></pre></td></tr></table>
</div>
</div><br/>
<br/>
<hr>
<br/>
<h1 id="分屏显示">分屏显示</h1>
<p>分屏有<code>screen</code>和<code>tmux</code>两个工具，我用的tmux，所以下面介绍tmux。</p>
<br/>
<p>tmux(terminal multiplexer)，有以下几个特点:</p>
<ul>
<li>可以开启多个会话(session)</li>
<li>一个会话可以开多个窗口(window)</li>
<li>一个窗口可以分为多个子窗口(subwindow)</li>
<li>多人复用一个会话，两人显示的内容一样，操作也会同步到会话界面上，也就是我能看到你的操作，你也能看到我的操作。</li>
</ul>
<br/>
<p>一些常用命令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 会话相关</span>

<span class="c1"># 新建会话</span>
tmux
tmux new -s session_name

<span class="c1"># 显示所有会话</span>
tmux ls

<span class="c1"># 接入会话</span>
tmux attach -t session_name

<span class="c1"># 关闭会话</span>
tmux kill-session -t session_name

<span class="c1"># 切换会话</span>
tmux switch -t session_name

<span class="c1"># 重命名会话</span>
tmux rename-session -t old_name new_name


<span class="c1"># tmux下ctrl + b 执行命令</span>

<span class="c1"># 帮助</span>
ctrl + b 之后 ?
<span class="c1"># 命令模式</span>
ctrl + b 之后 :

<span class="c1"># 新会话</span>
ctrl + b 之后 :new

<span class="c1"># 列出所有会话，并跳转到会话</span>
ctrl + b 之后 s

<span class="c1"># 断开当前会话</span>
ctrl + b 之后 d

<span class="c1"># 重命名当前会话</span>
ctrl + b 之后 $

<span class="c1"># 在当前会话加一个窗口</span>
ctrl + b 之后 c

<span class="c1"># 在一个会话的多个窗口中选择</span>
ctrl + b 之后 w


<span class="c1"># 窗口操作</span>

<span class="c1"># 当前会话下窗口切分</span>
<span class="c1"># 垂直分割</span>
ctrl +b 之后 %
<span class="c1"># 水平分割</span>
ctrl + b 之后 <span class="s2">&#34;
</span><span class="s2">
</span><span class="s2"># 窗口切换
</span><span class="s2"># ctrl + b 之后 方向键(上下左右)
</span><span class="s2">ctrl + b 之后 o
</span><span class="s2">
</span><span class="s2"># 窗口关闭
</span><span class="s2"># 或者exit也可以
</span><span class="s2">ctrl + b 之后 x
</span><span class="s2">
</span><span class="s2"># 关闭此会话中的所有窗口
</span><span class="s2">ctrl + b 之后 !
</span><span class="s2">
</span><span class="s2">
</span><span class="s2"># 修改窗口大小
</span><span class="s2"># 进入命令行模式
</span><span class="s2">ctrl + b 之后 :
</span><span class="s2">
</span><span class="s2"># 上U, 下D, 左L, 右R
</span><span class="s2"># 可以直接使用方向键控制不同窗口大小
</span><span class="s2">ctrl + b + 方向键(上下左右)
</span><span class="s2">
</span><span class="s2"># 当前窗口向左扩展10
</span><span class="s2">resize-pane -L 10
</span><span class="s2">
</span><span class="s2"># 当前窗口向右扩展10
</span><span class="s2">resize-pane -R 10
</span><span class="s2">
</span><span class="s2"># 当前窗口向上扩展10
</span><span class="s2">resize-pane -U 10
</span><span class="s2">
</span><span class="s2"># 当前窗口向下扩展10
</span><span class="s2">resize-pane -D 10
</span></code></pre></td></tr></table>
</div>
</div><br/>
<p>多人复用一个会话是tmux的一个很强的功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># Alice在A地远程登录
# 新建一个会话
tmux new -s alice_bob

# Bob在B地远程登录
# 查看tmux会话
tmux ls
# 追加此会话
tmux attach -t alice_bob
</code></pre></td></tr></table>
</div>
</div><p>此时两人共用一个会话，内容是共享的，都可以操作，彼此都能看见，这个很强了。</p>
<br/>
<br/>
<hr>
<br/>
<br/>
<h1 id="运维常见命令">运维常见命令</h1>
<p>以下命令来自：<a href="https://www.zhihu.com/question/23665108" target="_blank" rel="noopener noreffer ">知乎-运维工程师技能-知道创宇的回答</a></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Shell/ops-cmds.jpg"
        data-srcset="/images/Shell/ops-cmds.jpg, /images/Shell/ops-cmds.jpg 1.5x, /images/Shell/ops-cmds.jpg 2x"
        data-sizes="auto"
        alt="/images/Shell/ops-cmds.jpg"
        title="/images/Shell/ops-cmds.jpg" /></p>
<br/>
<ul>
<li><strong>I/O, Device</strong>:
<ul>
<li><code>blktrace</code>: 收集磁盘IO信息中当IO进行到块设备层时的详细信息</li>
<li><code>perf</code>: 全称Performance Event，是用来进行软件性能分析的工具。它不但可以分析指定应用程序的性能问题，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。</li>
<li><code>iotop</code>: 用来监视磁盘I/O使用状况的top类工具</li>
<li><code>iostat</code>: 用于监视系统输入输出设备和CPU的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。</li>
</ul>
</li>
<li><strong>Network</strong>:
<ul>
<li><code>ping</code>: 测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</li>
<li><code>ip</code>: 来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。</li>
<li><code>ifconfig</code>: 配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</li>
<li><code>dig</code>: 域名查询工具，可以用来测试域名系统工作是否正常。</li>
<li><code>iftop</code>: 实时流量监控工具,监控TCP/IP连接等,缺点就是无报表功能。</li>
<li><code>ifstat</code>: 网络接口监测工具,比较简单看网络流量。</li>
<li><code>nload</code>: 查看系统带宽</li>
<li><code>neghogs</code>: 查看进程流量</li>
<li><code>ethtool</code>: 检查网卡支持的带宽</li>
<li><code>tcpdump</code>: 是一款sniffer工具，它可以打印所有经过网络接口的数据包的头信息</li>
<li><code>netstat</code>: 打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</li>
<li><code>nicstat</code>: 是一款分析网卡流量信息的工具</li>
<li><code>sar</code>: 是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。</li>
<li><code>/proc</code>: 一个虚拟文件系统</li>
</ul>
</li>
<li><strong>FS</strong>:
<ul>
<li><code>fdisk</code>: 用于观察硬盘实体使用情况，也可对硬盘分区</li>
<li><code>du</code>: 对文件和目录磁盘使用的空间的查看</li>
<li><code>df</code>: 显示磁盘分区上的可使用的磁盘空间</li>
</ul>
</li>
<li><strong>Scheduler, VM</strong>:
<ul>
<li><code>strace</code>: strace命令是一个集诊断、调试、统计与一体的工具，我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。</li>
<li><code>vmstat</code>: 显示虚拟内存状态，但是它可以报告关于进程、内存、I/O等系统整体运行状态。</li>
<li><code>slabtop</code>: 以实时的方式显示内核slab缓冲区的细节信息</li>
<li><code>dstat</code>: 是一个全能系统信息统计工具</li>
<li><code>free</code>: 显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区</li>
<li><code>perf</code>:</li>
<li><code>top</code>: 实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具</li>
<li><code>pidstat</code>: 用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况</li>
<li><code>mpstat</code>: 主要用于多CPU环境下，它显示各个可用CPU的状态</li>
</ul>
</li>
</ul></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2017-10-24</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/linuxshell/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://zhang21.cn/linuxshell/" data-title="Shell" data-hashtags="Shell,Bash,Linux,Vim"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://zhang21.cn/linuxshell/" data-title="Shell"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://zhang21.cn/linuxshell/"><i class="fab fa-reddit fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://zhang21.cn/linuxshell/" data-title="Shell"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://zhang21.cn/linuxshell/" data-title="Shell"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/shell/">Shell</a>,&nbsp;<a href="/tags/bash/">Bash</a>,&nbsp;<a href="/tags/linux/">linux</a>,&nbsp;<a href="/tags/vim/">Vim</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/yaml/" class="prev" rel="prev" title="Yaml"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Yaml</a>
            <a href="/wireshark/" class="next" rel="next" title="Wireshark">Wireshark<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.83.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2017 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://zhang21.cn" target="_blank">Zhang21</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://zhang21.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":20},"comment":{},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"RZ22ZCTIDN","algoliaIndex":"hugo-index","algoliaSearchKey":"11ec277ef4d730e232eda9651548da78","highlightTag":"em","maxResultLength":20,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"twemoji":true};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
